var YospaceAdManagement = function (t) {
    var e = {};

    function i(r) {
        if (e[r]) return e[r].exports;
        var n = e[r] = {i: r, l: !1, exports: {}};
        return t[r].call(n.exports, n, n.exports, i), n.l = !0, n.exports
    }

    return i.m = t, i.c = e, i.d = function (t, e, r) {
        i.o(t, e) || Object.defineProperty(t, e, {enumerable: !0, get: r})
    }, i.r = function (t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: !0})
    }, i.t = function (t, e) {
        if (1 & e && (t = i(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var r = Object.create(null);
        if (i.r(r), Object.defineProperty(r, "default", {
            enumerable: !0,
            value: t
        }), 2 & e && "string" != typeof t) for (var n in t) i.d(r, n, function (e) {
            return t[e]
        }.bind(null, n));
        return r
    }, i.n = function (t) {
        var e = t && t.__esModule ? function () {
            return t.default
        } : function () {
            return t
        };
        return i.d(e, "a", e), e
    }, i.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i(i.s = 36)
}([function (t, e, i) {
    "use strict";
    (function (t) {
        i.d(e, "q", (function () {
            return n
        })), i.d(e, "d", (function () {
            return s
        })), i.d(e, "f", (function () {
            return a
        })), i.d(e, "g", (function () {
            return o
        })), i.d(e, "h", (function () {
            return l
        })), i.d(e, "t", (function () {
            return h
        })), i.d(e, "s", (function () {
            return c
        })), i.d(e, "r", (function () {
            return u
        })), i.d(e, "a", (function () {
            return d
        })), i.d(e, "e", (function () {
            return p
        })), i.d(e, "u", (function () {
            return f
        })), i.d(e, "b", (function () {
            return g
        })), i.d(e, "c", (function () {
            return v
        })), i.d(e, "k", (function () {
            return m
        })), i.d(e, "l", (function () {
            return y
        })), i.d(e, "j", (function () {
            return k
        })), i.d(e, "n", (function () {
            return T
        })), i.d(e, "i", (function () {
            return A
        })), i.d(e, "m", (function () {
            return E
        })), i.d(e, "p", (function () {
            return b
        })), i.d(e, "o", (function () {
            return w
        }));
        const r = t.env.HTTP_AGENT ? t.env.HTTP_AGENT : "Yospace SDK/3.0",
            n = ["mute", "unmute", "pause", "resume", "rewind", "playerExpand", "playerCollapse", "closeLinear", "skip"],
            s = ["creativeView"], a = ["interactiveStart"],
            o = ["loaded", "start", "firstQuartile", "midpoint", "thirdQuartile", "complete", "progress", "mute", "unmute", "pause", "resume", "rewind", "playerExpand", "playerCollapse", "closeLinear", "skip", "otherAdInteraction"],
            l = ["creativeView", "mute", "unmute", "pause", "resume", "rewind", "skip", "playerExpand", "playerCollapse", "adExpand", "adCollapse", "minimize", "overlayViewDuration", "acceptInvitation", "close", "otherAdInteraction"],
            h = ["creativeView", "close", "interactiveStart"], c = ["verificationNotExecuted"],
            u = ["loaded", "start", "firstQuartile", "midpoint", "thirdQuartile", "complete", "progress"],
            d = ["breakStart", "breakEnd"], p = Object.freeze({
                ADVERT_START_TIMESLOT: 5,
                DEFAULT_POLLING_DELAY: 6e3,
                EVENT_CUEPOINT_TOL: 10,
                EXPECTED_POLL_COMPLETE_TIME: 250,
                INTERSEGMENT_TIMEOUT: 2700,
                REQUEST_TIMEOUT: 5e3,
                MAX_CADENCE: 250,
                MIN_INTRASEGMENT_TIMEOUT: 2500,
                MIN_SEGMENT_LENGTH: 2e3,
                USER_AGENT: r
            });

        function f() {
            return "YoAdManagement: "
        }

        const g = 1, v = 2, m = "SESSIONIDENTIFIER", y = "LOCATION", k = "HOST", T = "PORT", A = "ANALYTICURL",
            E = "PAUSEURL", b = "SCHEME", w = "QUERYSTRING"
    }).call(this, i(4))
}, function (t, e, i) {
    "use strict";
    var r = i(7), n = Object.keys || function (t) {
        var e = [];
        for (var i in t) e.push(i);
        return e
    };
    t.exports = u;
    var s = Object.create(i(5));
    s.inherits = i(3);
    var a = i(14), o = i(12);
    s.inherits(u, a);
    for (var l = n(o.prototype), h = 0; h < l.length; h++) {
        var c = l[h];
        u.prototype[c] || (u.prototype[c] = o.prototype[c])
    }

    function u(t) {
        if (!(this instanceof u)) return new u(t);
        a.call(this, t), o.call(this, t), t && !1 === t.readable && (this.readable = !1), t && !1 === t.writable && (this.writable = !1), this.allowHalfOpen = !0, t && !1 === t.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", d)
    }

    function d() {
        this.allowHalfOpen || this._writableState.ended || r.nextTick(p, this)
    }

    function p(t) {
        t.end()
    }

    Object.defineProperty(u.prototype, "writableHighWaterMark", {
        enumerable: !1, get: function () {
            return this._writableState.highWaterMark
        }
    }), Object.defineProperty(u.prototype, "destroyed", {
        get: function () {
            return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
        }, set: function (t) {
            void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t)
        }
    }), u.prototype._destroy = function (t, e) {
        this.push(null), this.end(), r.nextTick(e, t)
    }
}, function (t, e) {
    var i;
    i = function () {
        return this
    }();
    try {
        i = i || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function (t, e) {
    "function" == typeof Object.create ? t.exports = function (t, e) {
        e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    } : t.exports = function (t, e) {
        if (e) {
            t.super_ = e;
            var i = function () {
            };
            i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = t
        }
    }
}, function (t, e) {
    var i, r, n = t.exports = {};

    function s() {
        throw new Error("setTimeout has not been defined")
    }

    function a() {
        throw new Error("clearTimeout has not been defined")
    }

    function o(t) {
        if (i === setTimeout) return setTimeout(t, 0);
        if ((i === s || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0);
        try {
            return i(t, 0)
        } catch (e) {
            try {
                return i.call(null, t, 0)
            } catch (e) {
                return i.call(this, t, 0)
            }
        }
    }

    !function () {
        try {
            i = "function" == typeof setTimeout ? setTimeout : s
        } catch (t) {
            i = s
        }
        try {
            r = "function" == typeof clearTimeout ? clearTimeout : a
        } catch (t) {
            r = a
        }
    }();
    var l, h = [], c = !1, u = -1;

    function d() {
        c && l && (c = !1, l.length ? h = l.concat(h) : u = -1, h.length && p())
    }

    function p() {
        if (!c) {
            var t = o(d);
            c = !0;
            for (var e = h.length; e;) {
                for (l = h, h = []; ++u < e;) l && l[u].run();
                u = -1, e = h.length
            }
            l = null, c = !1, function (t) {
                if (r === clearTimeout) return clearTimeout(t);
                if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t);
                try {
                    r(t)
                } catch (e) {
                    try {
                        return r.call(null, t)
                    } catch (e) {
                        return r.call(this, t)
                    }
                }
            }(t)
        }
    }

    function f(t, e) {
        this.fun = t, this.array = e
    }

    function g() {
    }

    n.nextTick = function (t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        h.push(new f(t, e)), 1 !== h.length || c || o(p)
    }, f.prototype.run = function () {
        this.fun.apply(null, this.array)
    }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = g, n.addListener = g, n.once = g, n.off = g, n.removeListener = g, n.removeAllListeners = g, n.emit = g, n.prependListener = g, n.prependOnceListener = g, n.listeners = function (t) {
        return []
    }, n.binding = function (t) {
        throw new Error("process.binding is not supported")
    }, n.cwd = function () {
        return "/"
    }, n.chdir = function (t) {
        throw new Error("process.chdir is not supported")
    }, n.umask = function () {
        return 0
    }
}, function (t, e, i) {
    function r(t) {
        return Object.prototype.toString.call(t)
    }

    e.isArray = function (t) {
        return Array.isArray ? Array.isArray(t) : "[object Array]" === r(t)
    }, e.isBoolean = function (t) {
        return "boolean" == typeof t
    }, e.isNull = function (t) {
        return null === t
    }, e.isNullOrUndefined = function (t) {
        return null == t
    }, e.isNumber = function (t) {
        return "number" == typeof t
    }, e.isString = function (t) {
        return "string" == typeof t
    }, e.isSymbol = function (t) {
        return "symbol" == typeof t
    }, e.isUndefined = function (t) {
        return void 0 === t
    }, e.isRegExp = function (t) {
        return "[object RegExp]" === r(t)
    }, e.isObject = function (t) {
        return "object" == typeof t && null !== t
    }, e.isDate = function (t) {
        return "[object Date]" === r(t)
    }, e.isError = function (t) {
        return "[object Error]" === r(t) || t instanceof Error
    }, e.isFunction = function (t) {
        return "function" == typeof t
    }, e.isPrimitive = function (t) {
        return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t
    }, e.isBuffer = i(6).Buffer.isBuffer
}, function (t, e, i) {
    "use strict";
    (function (t) {
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
        var r = i(19), n = i(20), s = i(21);

        function a() {
            return l.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function o(t, e) {
            if (a() < e) throw new RangeError("Invalid typed array length");
            return l.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = l.prototype : (null === t && (t = new l(e)), t.length = e), t
        }

        function l(t, e, i) {
            if (!(l.TYPED_ARRAY_SUPPORT || this instanceof l)) return new l(t, e, i);
            if ("number" == typeof t) {
                if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string");
                return u(this, t)
            }
            return h(this, t, e, i)
        }

        function h(t, e, i, r) {
            if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, i, r) {
                if (e.byteLength, i < 0 || e.byteLength < i) throw new RangeError("'offset' is out of bounds");
                if (e.byteLength < i + (r || 0)) throw new RangeError("'length' is out of bounds");
                e = void 0 === i && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, i) : new Uint8Array(e, i, r);
                l.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = l.prototype : t = d(t, e);
                return t
            }(t, e, i, r) : "string" == typeof e ? function (t, e, i) {
                "string" == typeof i && "" !== i || (i = "utf8");
                if (!l.isEncoding(i)) throw new TypeError('"encoding" must be a valid string encoding');
                var r = 0 | f(e, i), n = (t = o(t, r)).write(e, i);
                n !== r && (t = t.slice(0, n));
                return t
            }(t, e, i) : function (t, e) {
                if (l.isBuffer(e)) {
                    var i = 0 | p(e.length);
                    return 0 === (t = o(t, i)).length || e.copy(t, 0, 0, i), t
                }
                if (e) {
                    if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (r = e.length) != r ? o(t, 0) : d(t, e);
                    if ("Buffer" === e.type && s(e.data)) return d(t, e.data)
                }
                var r;
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }(t, e)
        }

        function c(t) {
            if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
            if (t < 0) throw new RangeError('"size" argument must not be negative')
        }

        function u(t, e) {
            if (c(e), t = o(t, e < 0 ? 0 : 0 | p(e)), !l.TYPED_ARRAY_SUPPORT) for (var i = 0; i < e; ++i) t[i] = 0;
            return t
        }

        function d(t, e) {
            var i = e.length < 0 ? 0 : 0 | p(e.length);
            t = o(t, i);
            for (var r = 0; r < i; r += 1) t[r] = 255 & e[r];
            return t
        }

        function p(t) {
            if (t >= a()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
            return 0 | t
        }

        function f(t, e) {
            if (l.isBuffer(t)) return t.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
            "string" != typeof t && (t = "" + t);
            var i = t.length;
            if (0 === i) return 0;
            for (var r = !1; ;) switch (e) {
                case"ascii":
                case"latin1":
                case"binary":
                    return i;
                case"utf8":
                case"utf-8":
                case void 0:
                    return V(t).length;
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return 2 * i;
                case"hex":
                    return i >>> 1;
                case"base64":
                    return H(t).length;
                default:
                    if (r) return V(t).length;
                    e = ("" + e).toLowerCase(), r = !0
            }
        }

        function g(t, e, i) {
            var r = !1;
            if ((void 0 === e || e < 0) && (e = 0), e > this.length) return "";
            if ((void 0 === i || i > this.length) && (i = this.length), i <= 0) return "";
            if ((i >>>= 0) <= (e >>>= 0)) return "";
            for (t || (t = "utf8"); ;) switch (t) {
                case"hex":
                    return P(this, e, i);
                case"utf8":
                case"utf-8":
                    return C(this, e, i);
                case"ascii":
                    return I(this, e, i);
                case"latin1":
                case"binary":
                    return D(this, e, i);
                case"base64":
                    return S(this, e, i);
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return R(this, e, i);
                default:
                    if (r) throw new TypeError("Unknown encoding: " + t);
                    t = (t + "").toLowerCase(), r = !0
            }
        }

        function v(t, e, i) {
            var r = t[e];
            t[e] = t[i], t[i] = r
        }

        function m(t, e, i, r, n) {
            if (0 === t.length) return -1;
            if ("string" == typeof i ? (r = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, isNaN(i) && (i = n ? 0 : t.length - 1), i < 0 && (i = t.length + i), i >= t.length) {
                if (n) return -1;
                i = t.length - 1
            } else if (i < 0) {
                if (!n) return -1;
                i = 0
            }
            if ("string" == typeof e && (e = l.from(e, r)), l.isBuffer(e)) return 0 === e.length ? -1 : y(t, e, i, r, n);
            if ("number" == typeof e) return e &= 255, l.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(t, e, i) : Uint8Array.prototype.lastIndexOf.call(t, e, i) : y(t, [e], i, r, n);
            throw new TypeError("val must be string, number or Buffer")
        }

        function y(t, e, i, r, n) {
            var s, a = 1, o = t.length, l = e.length;
            if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (t.length < 2 || e.length < 2) return -1;
                a = 2, o /= 2, l /= 2, i /= 2
            }

            function h(t, e) {
                return 1 === a ? t[e] : t.readUInt16BE(e * a)
            }

            if (n) {
                var c = -1;
                for (s = i; s < o; s++) if (h(t, s) === h(e, -1 === c ? 0 : s - c)) {
                    if (-1 === c && (c = s), s - c + 1 === l) return c * a
                } else -1 !== c && (s -= s - c), c = -1
            } else for (i + l > o && (i = o - l), s = i; s >= 0; s--) {
                for (var u = !0, d = 0; d < l; d++) if (h(t, s + d) !== h(e, d)) {
                    u = !1;
                    break
                }
                if (u) return s
            }
            return -1
        }

        function k(t, e, i, r) {
            i = Number(i) || 0;
            var n = t.length - i;
            r ? (r = Number(r)) > n && (r = n) : r = n;
            var s = e.length;
            if (s % 2 != 0) throw new TypeError("Invalid hex string");
            r > s / 2 && (r = s / 2);
            for (var a = 0; a < r; ++a) {
                var o = parseInt(e.substr(2 * a, 2), 16);
                if (isNaN(o)) return a;
                t[i + a] = o
            }
            return a
        }

        function T(t, e, i, r) {
            return j(V(e, t.length - i), t, i, r)
        }

        function A(t, e, i, r) {
            return j(function (t) {
                for (var e = [], i = 0; i < t.length; ++i) e.push(255 & t.charCodeAt(i));
                return e
            }(e), t, i, r)
        }

        function E(t, e, i, r) {
            return A(t, e, i, r)
        }

        function b(t, e, i, r) {
            return j(H(e), t, i, r)
        }

        function w(t, e, i, r) {
            return j(function (t, e) {
                for (var i, r, n, s = [], a = 0; a < t.length && !((e -= 2) < 0); ++a) i = t.charCodeAt(a), r = i >> 8, n = i % 256, s.push(n), s.push(r);
                return s
            }(e, t.length - i), t, i, r)
        }

        function S(t, e, i) {
            return 0 === e && i === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, i))
        }

        function C(t, e, i) {
            i = Math.min(t.length, i);
            for (var r = [], n = e; n < i;) {
                var s, a, o, l, h = t[n], c = null, u = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                if (n + u <= i) switch (u) {
                    case 1:
                        h < 128 && (c = h);
                        break;
                    case 2:
                        128 == (192 & (s = t[n + 1])) && (l = (31 & h) << 6 | 63 & s) > 127 && (c = l);
                        break;
                    case 3:
                        s = t[n + 1], a = t[n + 2], 128 == (192 & s) && 128 == (192 & a) && (l = (15 & h) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (l < 55296 || l > 57343) && (c = l);
                        break;
                    case 4:
                        s = t[n + 1], a = t[n + 2], o = t[n + 3], 128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (l = (15 & h) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) > 65535 && l < 1114112 && (c = l)
                }
                null === c ? (c = 65533, u = 1) : c > 65535 && (c -= 65536, r.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), r.push(c), n += u
            }
            return function (t) {
                var e = t.length;
                if (e <= 4096) return String.fromCharCode.apply(String, t);
                var i = "", r = 0;
                for (; r < e;) i += String.fromCharCode.apply(String, t.slice(r, r += 4096));
                return i
            }(r)
        }

        e.Buffer = l, e.SlowBuffer = function (t) {
            +t != t && (t = 0);
            return l.alloc(+t)
        }, e.INSPECT_MAX_BYTES = 50, l.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () {
            try {
                var t = new Uint8Array(1);
                return t.__proto__ = {
                    __proto__: Uint8Array.prototype, foo: function () {
                        return 42
                    }
                }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
            } catch (t) {
                return !1
            }
        }(), e.kMaxLength = a(), l.poolSize = 8192, l._augment = function (t) {
            return t.__proto__ = l.prototype, t
        }, l.from = function (t, e, i) {
            return h(null, t, e, i)
        }, l.TYPED_ARRAY_SUPPORT && (l.prototype.__proto__ = Uint8Array.prototype, l.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && l[Symbol.species] === l && Object.defineProperty(l, Symbol.species, {
            value: null,
            configurable: !0
        })), l.alloc = function (t, e, i) {
            return function (t, e, i, r) {
                return c(e), e <= 0 ? o(t, e) : void 0 !== i ? "string" == typeof r ? o(t, e).fill(i, r) : o(t, e).fill(i) : o(t, e)
            }(null, t, e, i)
        }, l.allocUnsafe = function (t) {
            return u(null, t)
        }, l.allocUnsafeSlow = function (t) {
            return u(null, t)
        }, l.isBuffer = function (t) {
            return !(null == t || !t._isBuffer)
        }, l.compare = function (t, e) {
            if (!l.isBuffer(t) || !l.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
            if (t === e) return 0;
            for (var i = t.length, r = e.length, n = 0, s = Math.min(i, r); n < s; ++n) if (t[n] !== e[n]) {
                i = t[n], r = e[n];
                break
            }
            return i < r ? -1 : r < i ? 1 : 0
        }, l.isEncoding = function (t) {
            switch (String(t).toLowerCase()) {
                case"hex":
                case"utf8":
                case"utf-8":
                case"ascii":
                case"latin1":
                case"binary":
                case"base64":
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return !0;
                default:
                    return !1
            }
        }, l.concat = function (t, e) {
            if (!s(t)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t.length) return l.alloc(0);
            var i;
            if (void 0 === e) for (e = 0, i = 0; i < t.length; ++i) e += t[i].length;
            var r = l.allocUnsafe(e), n = 0;
            for (i = 0; i < t.length; ++i) {
                var a = t[i];
                if (!l.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
                a.copy(r, n), n += a.length
            }
            return r
        }, l.byteLength = f, l.prototype._isBuffer = !0, l.prototype.swap16 = function () {
            var t = this.length;
            if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var e = 0; e < t; e += 2) v(this, e, e + 1);
            return this
        }, l.prototype.swap32 = function () {
            var t = this.length;
            if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var e = 0; e < t; e += 4) v(this, e, e + 3), v(this, e + 1, e + 2);
            return this
        }, l.prototype.swap64 = function () {
            var t = this.length;
            if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var e = 0; e < t; e += 8) v(this, e, e + 7), v(this, e + 1, e + 6), v(this, e + 2, e + 5), v(this, e + 3, e + 4);
            return this
        }, l.prototype.toString = function () {
            var t = 0 | this.length;
            return 0 === t ? "" : 0 === arguments.length ? C(this, 0, t) : g.apply(this, arguments)
        }, l.prototype.equals = function (t) {
            if (!l.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === l.compare(this, t)
        }, l.prototype.inspect = function () {
            var t = "", i = e.INSPECT_MAX_BYTES;
            return this.length > 0 && (t = this.toString("hex", 0, i).match(/.{2}/g).join(" "), this.length > i && (t += " ... ")), "<Buffer " + t + ">"
        }, l.prototype.compare = function (t, e, i, r, n) {
            if (!l.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === e && (e = 0), void 0 === i && (i = t ? t.length : 0), void 0 === r && (r = 0), void 0 === n && (n = this.length), e < 0 || i > t.length || r < 0 || n > this.length) throw new RangeError("out of range index");
            if (r >= n && e >= i) return 0;
            if (r >= n) return -1;
            if (e >= i) return 1;
            if (this === t) return 0;
            for (var s = (n >>>= 0) - (r >>>= 0), a = (i >>>= 0) - (e >>>= 0), o = Math.min(s, a), h = this.slice(r, n), c = t.slice(e, i), u = 0; u < o; ++u) if (h[u] !== c[u]) {
                s = h[u], a = c[u];
                break
            }
            return s < a ? -1 : a < s ? 1 : 0
        }, l.prototype.includes = function (t, e, i) {
            return -1 !== this.indexOf(t, e, i)
        }, l.prototype.indexOf = function (t, e, i) {
            return m(this, t, e, i, !0)
        }, l.prototype.lastIndexOf = function (t, e, i) {
            return m(this, t, e, i, !1)
        }, l.prototype.write = function (t, e, i, r) {
            if (void 0 === e) r = "utf8", i = this.length, e = 0; else if (void 0 === i && "string" == typeof e) r = e, i = this.length, e = 0; else {
                if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                e |= 0, isFinite(i) ? (i |= 0, void 0 === r && (r = "utf8")) : (r = i, i = void 0)
            }
            var n = this.length - e;
            if ((void 0 === i || i > n) && (i = n), t.length > 0 && (i < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            r || (r = "utf8");
            for (var s = !1; ;) switch (r) {
                case"hex":
                    return k(this, t, e, i);
                case"utf8":
                case"utf-8":
                    return T(this, t, e, i);
                case"ascii":
                    return A(this, t, e, i);
                case"latin1":
                case"binary":
                    return E(this, t, e, i);
                case"base64":
                    return b(this, t, e, i);
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return w(this, t, e, i);
                default:
                    if (s) throw new TypeError("Unknown encoding: " + r);
                    r = ("" + r).toLowerCase(), s = !0
            }
        }, l.prototype.toJSON = function () {
            return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
        };

        function I(t, e, i) {
            var r = "";
            i = Math.min(t.length, i);
            for (var n = e; n < i; ++n) r += String.fromCharCode(127 & t[n]);
            return r
        }

        function D(t, e, i) {
            var r = "";
            i = Math.min(t.length, i);
            for (var n = e; n < i; ++n) r += String.fromCharCode(t[n]);
            return r
        }

        function P(t, e, i) {
            var r = t.length;
            (!e || e < 0) && (e = 0), (!i || i < 0 || i > r) && (i = r);
            for (var n = "", s = e; s < i; ++s) n += F(t[s]);
            return n
        }

        function R(t, e, i) {
            for (var r = t.slice(e, i), n = "", s = 0; s < r.length; s += 2) n += String.fromCharCode(r[s] + 256 * r[s + 1]);
            return n
        }

        function L(t, e, i) {
            if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
            if (t + e > i) throw new RangeError("Trying to access beyond buffer length")
        }

        function N(t, e, i, r, n, s) {
            if (!l.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > n || e < s) throw new RangeError('"value" argument is out of bounds');
            if (i + r > t.length) throw new RangeError("Index out of range")
        }

        function _(t, e, i, r) {
            e < 0 && (e = 65535 + e + 1);
            for (var n = 0, s = Math.min(t.length - i, 2); n < s; ++n) t[i + n] = (e & 255 << 8 * (r ? n : 1 - n)) >>> 8 * (r ? n : 1 - n)
        }

        function M(t, e, i, r) {
            e < 0 && (e = 4294967295 + e + 1);
            for (var n = 0, s = Math.min(t.length - i, 4); n < s; ++n) t[i + n] = e >>> 8 * (r ? n : 3 - n) & 255
        }

        function B(t, e, i, r, n, s) {
            if (i + r > t.length) throw new RangeError("Index out of range");
            if (i < 0) throw new RangeError("Index out of range")
        }

        function U(t, e, i, r, s) {
            return s || B(t, 0, i, 4), n.write(t, e, i, r, 23, 4), i + 4
        }

        function x(t, e, i, r, s) {
            return s || B(t, 0, i, 8), n.write(t, e, i, r, 52, 8), i + 8
        }

        l.prototype.slice = function (t, e) {
            var i, r = this.length;
            if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), e < t && (e = t), l.TYPED_ARRAY_SUPPORT) (i = this.subarray(t, e)).__proto__ = l.prototype; else {
                var n = e - t;
                i = new l(n, void 0);
                for (var s = 0; s < n; ++s) i[s] = this[s + t]
            }
            return i
        }, l.prototype.readUIntLE = function (t, e, i) {
            t |= 0, e |= 0, i || L(t, e, this.length);
            for (var r = this[t], n = 1, s = 0; ++s < e && (n *= 256);) r += this[t + s] * n;
            return r
        }, l.prototype.readUIntBE = function (t, e, i) {
            t |= 0, e |= 0, i || L(t, e, this.length);
            for (var r = this[t + --e], n = 1; e > 0 && (n *= 256);) r += this[t + --e] * n;
            return r
        }, l.prototype.readUInt8 = function (t, e) {
            return e || L(t, 1, this.length), this[t]
        }, l.prototype.readUInt16LE = function (t, e) {
            return e || L(t, 2, this.length), this[t] | this[t + 1] << 8
        }, l.prototype.readUInt16BE = function (t, e) {
            return e || L(t, 2, this.length), this[t] << 8 | this[t + 1]
        }, l.prototype.readUInt32LE = function (t, e) {
            return e || L(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }, l.prototype.readUInt32BE = function (t, e) {
            return e || L(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }, l.prototype.readIntLE = function (t, e, i) {
            t |= 0, e |= 0, i || L(t, e, this.length);
            for (var r = this[t], n = 1, s = 0; ++s < e && (n *= 256);) r += this[t + s] * n;
            return r >= (n *= 128) && (r -= Math.pow(2, 8 * e)), r
        }, l.prototype.readIntBE = function (t, e, i) {
            t |= 0, e |= 0, i || L(t, e, this.length);
            for (var r = e, n = 1, s = this[t + --r]; r > 0 && (n *= 256);) s += this[t + --r] * n;
            return s >= (n *= 128) && (s -= Math.pow(2, 8 * e)), s
        }, l.prototype.readInt8 = function (t, e) {
            return e || L(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }, l.prototype.readInt16LE = function (t, e) {
            e || L(t, 2, this.length);
            var i = this[t] | this[t + 1] << 8;
            return 32768 & i ? 4294901760 | i : i
        }, l.prototype.readInt16BE = function (t, e) {
            e || L(t, 2, this.length);
            var i = this[t + 1] | this[t] << 8;
            return 32768 & i ? 4294901760 | i : i
        }, l.prototype.readInt32LE = function (t, e) {
            return e || L(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }, l.prototype.readInt32BE = function (t, e) {
            return e || L(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }, l.prototype.readFloatLE = function (t, e) {
            return e || L(t, 4, this.length), n.read(this, t, !0, 23, 4)
        }, l.prototype.readFloatBE = function (t, e) {
            return e || L(t, 4, this.length), n.read(this, t, !1, 23, 4)
        }, l.prototype.readDoubleLE = function (t, e) {
            return e || L(t, 8, this.length), n.read(this, t, !0, 52, 8)
        }, l.prototype.readDoubleBE = function (t, e) {
            return e || L(t, 8, this.length), n.read(this, t, !1, 52, 8)
        }, l.prototype.writeUIntLE = function (t, e, i, r) {
            (t = +t, e |= 0, i |= 0, r) || N(this, t, e, i, Math.pow(2, 8 * i) - 1, 0);
            var n = 1, s = 0;
            for (this[e] = 255 & t; ++s < i && (n *= 256);) this[e + s] = t / n & 255;
            return e + i
        }, l.prototype.writeUIntBE = function (t, e, i, r) {
            (t = +t, e |= 0, i |= 0, r) || N(this, t, e, i, Math.pow(2, 8 * i) - 1, 0);
            var n = i - 1, s = 1;
            for (this[e + n] = 255 & t; --n >= 0 && (s *= 256);) this[e + n] = t / s & 255;
            return e + i
        }, l.prototype.writeUInt8 = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 1, 255, 0), l.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1
        }, l.prototype.writeUInt16LE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 2, 65535, 0), l.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : _(this, t, e, !0), e + 2
        }, l.prototype.writeUInt16BE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 2, 65535, 0), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : _(this, t, e, !1), e + 2
        }, l.prototype.writeUInt32LE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 4, 4294967295, 0), l.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : M(this, t, e, !0), e + 4
        }, l.prototype.writeUInt32BE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 4, 4294967295, 0), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : M(this, t, e, !1), e + 4
        }, l.prototype.writeIntLE = function (t, e, i, r) {
            if (t = +t, e |= 0, !r) {
                var n = Math.pow(2, 8 * i - 1);
                N(this, t, e, i, n - 1, -n)
            }
            var s = 0, a = 1, o = 0;
            for (this[e] = 255 & t; ++s < i && (a *= 256);) t < 0 && 0 === o && 0 !== this[e + s - 1] && (o = 1), this[e + s] = (t / a >> 0) - o & 255;
            return e + i
        }, l.prototype.writeIntBE = function (t, e, i, r) {
            if (t = +t, e |= 0, !r) {
                var n = Math.pow(2, 8 * i - 1);
                N(this, t, e, i, n - 1, -n)
            }
            var s = i - 1, a = 1, o = 0;
            for (this[e + s] = 255 & t; --s >= 0 && (a *= 256);) t < 0 && 0 === o && 0 !== this[e + s + 1] && (o = 1), this[e + s] = (t / a >> 0) - o & 255;
            return e + i
        }, l.prototype.writeInt8 = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 1, 127, -128), l.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1
        }, l.prototype.writeInt16LE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 2, 32767, -32768), l.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : _(this, t, e, !0), e + 2
        }, l.prototype.writeInt16BE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 2, 32767, -32768), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : _(this, t, e, !1), e + 2
        }, l.prototype.writeInt32LE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 4, 2147483647, -2147483648), l.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : M(this, t, e, !0), e + 4
        }, l.prototype.writeInt32BE = function (t, e, i) {
            return t = +t, e |= 0, i || N(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), l.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : M(this, t, e, !1), e + 4
        }, l.prototype.writeFloatLE = function (t, e, i) {
            return U(this, t, e, !0, i)
        }, l.prototype.writeFloatBE = function (t, e, i) {
            return U(this, t, e, !1, i)
        }, l.prototype.writeDoubleLE = function (t, e, i) {
            return x(this, t, e, !0, i)
        }, l.prototype.writeDoubleBE = function (t, e, i) {
            return x(this, t, e, !1, i)
        }, l.prototype.copy = function (t, e, i, r) {
            if (i || (i = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < i && (r = i), r === i) return 0;
            if (0 === t.length || 0 === this.length) return 0;
            if (e < 0) throw new RangeError("targetStart out of bounds");
            if (i < 0 || i >= this.length) throw new RangeError("sourceStart out of bounds");
            if (r < 0) throw new RangeError("sourceEnd out of bounds");
            r > this.length && (r = this.length), t.length - e < r - i && (r = t.length - e + i);
            var n, s = r - i;
            if (this === t && i < e && e < r) for (n = s - 1; n >= 0; --n) t[n + e] = this[n + i]; else if (s < 1e3 || !l.TYPED_ARRAY_SUPPORT) for (n = 0; n < s; ++n) t[n + e] = this[n + i]; else Uint8Array.prototype.set.call(t, this.subarray(i, i + s), e);
            return s
        }, l.prototype.fill = function (t, e, i, r) {
            if ("string" == typeof t) {
                if ("string" == typeof e ? (r = e, e = 0, i = this.length) : "string" == typeof i && (r = i, i = this.length), 1 === t.length) {
                    var n = t.charCodeAt(0);
                    n < 256 && (t = n)
                }
                if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
                if ("string" == typeof r && !l.isEncoding(r)) throw new TypeError("Unknown encoding: " + r)
            } else "number" == typeof t && (t &= 255);
            if (e < 0 || this.length < e || this.length < i) throw new RangeError("Out of range index");
            if (i <= e) return this;
            var s;
            if (e >>>= 0, i = void 0 === i ? this.length : i >>> 0, t || (t = 0), "number" == typeof t) for (s = e; s < i; ++s) this[s] = t; else {
                var a = l.isBuffer(t) ? t : V(new l(t, r).toString()), o = a.length;
                for (s = 0; s < i - e; ++s) this[s + e] = a[s % o]
            }
            return this
        };
        var O = /[^+\/0-9A-Za-z-_]/g;

        function F(t) {
            return t < 16 ? "0" + t.toString(16) : t.toString(16)
        }

        function V(t, e) {
            var i;
            e = e || 1 / 0;
            for (var r = t.length, n = null, s = [], a = 0; a < r; ++a) {
                if ((i = t.charCodeAt(a)) > 55295 && i < 57344) {
                    if (!n) {
                        if (i > 56319) {
                            (e -= 3) > -1 && s.push(239, 191, 189);
                            continue
                        }
                        if (a + 1 === r) {
                            (e -= 3) > -1 && s.push(239, 191, 189);
                            continue
                        }
                        n = i;
                        continue
                    }
                    if (i < 56320) {
                        (e -= 3) > -1 && s.push(239, 191, 189), n = i;
                        continue
                    }
                    i = 65536 + (n - 55296 << 10 | i - 56320)
                } else n && (e -= 3) > -1 && s.push(239, 191, 189);
                if (n = null, i < 128) {
                    if ((e -= 1) < 0) break;
                    s.push(i)
                } else if (i < 2048) {
                    if ((e -= 2) < 0) break;
                    s.push(i >> 6 | 192, 63 & i | 128)
                } else if (i < 65536) {
                    if ((e -= 3) < 0) break;
                    s.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128)
                } else {
                    if (!(i < 1114112)) throw new Error("Invalid code point");
                    if ((e -= 4) < 0) break;
                    s.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128)
                }
            }
            return s
        }

        function H(t) {
            return r.toByteArray(function (t) {
                if ((t = function (t) {
                    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                }(t).replace(O, "")).length < 2) return "";
                for (; t.length % 4 != 0;) t += "=";
                return t
            }(t))
        }

        function j(t, e, i, r) {
            for (var n = 0; n < r && !(n + i >= e.length || n >= t.length); ++n) e[n + i] = t[n];
            return n
        }
    }).call(this, i(2))
}, function (t, e, i) {
    "use strict";
    (function (e) {
        void 0 === e || !e.version || 0 === e.version.indexOf("v0.") || 0 === e.version.indexOf("v1.") && 0 !== e.version.indexOf("v1.8.") ? t.exports = {
            nextTick: function (t, i, r, n) {
                if ("function" != typeof t) throw new TypeError('"callback" argument must be a function');
                var s, a, o = arguments.length;
                switch (o) {
                    case 0:
                    case 1:
                        return e.nextTick(t);
                    case 2:
                        return e.nextTick((function () {
                            t.call(null, i)
                        }));
                    case 3:
                        return e.nextTick((function () {
                            t.call(null, i, r)
                        }));
                    case 4:
                        return e.nextTick((function () {
                            t.call(null, i, r, n)
                        }));
                    default:
                        for (s = new Array(o - 1), a = 0; a < s.length;) s[a++] = arguments[a];
                        return e.nextTick((function () {
                            t.apply(null, s)
                        }))
                }
            }
        } : t.exports = e
    }).call(this, i(4))
}, function (t, e, i) {
    (function (t) {
        !function (e) {
            e.parser = function (t, e) {
                return new s(t, e)
            }, e.SAXParser = s, e.SAXStream = o, e.createStream = function (t, e) {
                return new o(t, e)
            }, e.MAX_BUFFER_LENGTH = 65536;
            var r,
                n = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];

            function s(t, i) {
                if (!(this instanceof s)) return new s(t, i);
                !function (t) {
                    for (var e = 0, i = n.length; e < i; e++) t[n[e]] = ""
                }(this), this.q = this.c = "", this.bufferCheckPosition = e.MAX_BUFFER_LENGTH, this.opt = i || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], this.closed = this.closedRoot = this.sawRoot = !1, this.tag = this.error = null, this.strict = !!t, this.noscript = !(!t && !this.opt.noscript), this.state = E.BEGIN, this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), this.attribList = [], this.opt.xmlns && (this.ns = Object.create(h)), this.trackPosition = !1 !== this.opt.position, this.trackPosition && (this.position = this.line = this.column = 0), w(this, "onready")
            }

            e.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function (t) {
                function e() {
                }

                return e.prototype = t, new e
            }), Object.keys || (Object.keys = function (t) {
                var e = [];
                for (var i in t) t.hasOwnProperty(i) && e.push(i);
                return e
            }), s.prototype = {
                end: function () {
                    P(this)
                }, write: function (t) {
                    if (this.error) throw this.error;
                    if (this.closed) return D(this, "Cannot write after close. Assign an onready handler.");
                    if (null === t) return P(this);
                    "object" == typeof t && (t = t.toString());
                    var i = 0, r = "";
                    for (; r = O(t, i++), this.c = r, r;) switch (this.trackPosition && (this.position++, "\n" === r ? (this.line++, this.column = 0) : this.column++), this.state) {
                        case E.BEGIN:
                            if (this.state = E.BEGIN_WHITESPACE, "\ufeff" === r) continue;
                            x(this, r);
                            continue;
                        case E.BEGIN_WHITESPACE:
                            x(this, r);
                            continue;
                        case E.TEXT:
                            if (this.sawRoot && !this.closedRoot) {
                                for (var s = i - 1; r && "<" !== r && "&" !== r;) (r = O(t, i++)) && this.trackPosition && (this.position++, "\n" === r ? (this.line++, this.column = 0) : this.column++);
                                this.textNode += t.substring(s, i - 1)
                            }
                            "<" !== r || this.sawRoot && this.closedRoot && !this.strict ? (f(r) || this.sawRoot && !this.closedRoot || R(this, "Text data outside of root node."), "&" === r ? this.state = E.TEXT_ENTITY : this.textNode += r) : (this.state = E.OPEN_WAKA, this.startTagPosition = this.position);
                            continue;
                        case E.SCRIPT:
                            "<" === r ? this.state = E.SCRIPT_ENDING : this.script += r;
                            continue;
                        case E.SCRIPT_ENDING:
                            "/" === r ? this.state = E.CLOSE_TAG : (this.script += "<" + r, this.state = E.SCRIPT);
                            continue;
                        case E.OPEN_WAKA:
                            if ("!" === r) this.state = E.SGML_DECL, this.sgmlDecl = ""; else if (f(r)) ; else if (m(c, r)) this.state = E.OPEN_TAG, this.tagName = r; else if ("/" === r) this.state = E.CLOSE_TAG, this.tagName = ""; else if ("?" === r) this.state = E.PROC_INST, this.procInstName = this.procInstBody = ""; else {
                                if (R(this, "Unencoded <"), this.startTagPosition + 1 < this.position) {
                                    var a = this.position - this.startTagPosition;
                                    r = new Array(a).join(" ") + r
                                }
                                this.textNode += "<" + r, this.state = E.TEXT
                            }
                            continue;
                        case E.SGML_DECL:
                            "[CDATA[" === (this.sgmlDecl + r).toUpperCase() ? (S(this, "onopencdata"), this.state = E.CDATA, this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + r === "--" ? (this.state = E.COMMENT, this.comment = "", this.sgmlDecl = "") : "DOCTYPE" === (this.sgmlDecl + r).toUpperCase() ? (this.state = E.DOCTYPE, (this.doctype || this.sawRoot) && R(this, "Inappropriately located doctype declaration"), this.doctype = "", this.sgmlDecl = "") : ">" === r ? (S(this, "onsgmldeclaration", this.sgmlDecl), this.sgmlDecl = "", this.state = E.TEXT) : g(r) ? (this.state = E.SGML_DECL_QUOTED, this.sgmlDecl += r) : this.sgmlDecl += r;
                            continue;
                        case E.SGML_DECL_QUOTED:
                            r === this.q && (this.state = E.SGML_DECL, this.q = ""), this.sgmlDecl += r;
                            continue;
                        case E.DOCTYPE:
                            ">" === r ? (this.state = E.TEXT, S(this, "ondoctype", this.doctype), this.doctype = !0) : (this.doctype += r, "[" === r ? this.state = E.DOCTYPE_DTD : g(r) && (this.state = E.DOCTYPE_QUOTED, this.q = r));
                            continue;
                        case E.DOCTYPE_QUOTED:
                            this.doctype += r, r === this.q && (this.q = "", this.state = E.DOCTYPE);
                            continue;
                        case E.DOCTYPE_DTD:
                            this.doctype += r, "]" === r ? this.state = E.DOCTYPE : g(r) && (this.state = E.DOCTYPE_DTD_QUOTED, this.q = r);
                            continue;
                        case E.DOCTYPE_DTD_QUOTED:
                            this.doctype += r, r === this.q && (this.state = E.DOCTYPE_DTD, this.q = "");
                            continue;
                        case E.COMMENT:
                            "-" === r ? this.state = E.COMMENT_ENDING : this.comment += r;
                            continue;
                        case E.COMMENT_ENDING:
                            "-" === r ? (this.state = E.COMMENT_ENDED, this.comment = I(this.opt, this.comment), this.comment && S(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + r, this.state = E.COMMENT);
                            continue;
                        case E.COMMENT_ENDED:
                            ">" !== r ? (R(this, "Malformed comment"), this.comment += "--" + r, this.state = E.COMMENT) : this.state = E.TEXT;
                            continue;
                        case E.CDATA:
                            "]" === r ? this.state = E.CDATA_ENDING : this.cdata += r;
                            continue;
                        case E.CDATA_ENDING:
                            "]" === r ? this.state = E.CDATA_ENDING_2 : (this.cdata += "]" + r, this.state = E.CDATA);
                            continue;
                        case E.CDATA_ENDING_2:
                            ">" === r ? (this.cdata && S(this, "oncdata", this.cdata), S(this, "onclosecdata"), this.cdata = "", this.state = E.TEXT) : "]" === r ? this.cdata += "]" : (this.cdata += "]]" + r, this.state = E.CDATA);
                            continue;
                        case E.PROC_INST:
                            "?" === r ? this.state = E.PROC_INST_ENDING : f(r) ? this.state = E.PROC_INST_BODY : this.procInstName += r;
                            continue;
                        case E.PROC_INST_BODY:
                            if (!this.procInstBody && f(r)) continue;
                            "?" === r ? this.state = E.PROC_INST_ENDING : this.procInstBody += r;
                            continue;
                        case E.PROC_INST_ENDING:
                            ">" === r ? (S(this, "onprocessinginstruction", {
                                name: this.procInstName,
                                body: this.procInstBody
                            }), this.procInstName = this.procInstBody = "", this.state = E.TEXT) : (this.procInstBody += "?" + r, this.state = E.PROC_INST_BODY);
                            continue;
                        case E.OPEN_TAG:
                            m(u, r) ? this.tagName += r : (L(this), ">" === r ? M(this) : "/" === r ? this.state = E.OPEN_TAG_SLASH : (f(r) || R(this, "Invalid character in tag name"), this.state = E.ATTRIB));
                            continue;
                        case E.OPEN_TAG_SLASH:
                            ">" === r ? (M(this, !0), B(this)) : (R(this, "Forward-slash in opening tag not followed by >"), this.state = E.ATTRIB);
                            continue;
                        case E.ATTRIB:
                            if (f(r)) continue;
                            ">" === r ? M(this) : "/" === r ? this.state = E.OPEN_TAG_SLASH : m(c, r) ? (this.attribName = r, this.attribValue = "", this.state = E.ATTRIB_NAME) : R(this, "Invalid attribute name");
                            continue;
                        case E.ATTRIB_NAME:
                            "=" === r ? this.state = E.ATTRIB_VALUE : ">" === r ? (R(this, "Attribute without value"), this.attribValue = this.attribName, _(this), M(this)) : f(r) ? this.state = E.ATTRIB_NAME_SAW_WHITE : m(u, r) ? this.attribName += r : R(this, "Invalid attribute name");
                            continue;
                        case E.ATTRIB_NAME_SAW_WHITE:
                            if ("=" === r) this.state = E.ATTRIB_VALUE; else {
                                if (f(r)) continue;
                                R(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", this.attribValue = "", S(this, "onattribute", {
                                    name: this.attribName,
                                    value: ""
                                }), this.attribName = "", ">" === r ? M(this) : m(c, r) ? (this.attribName = r, this.state = E.ATTRIB_NAME) : (R(this, "Invalid attribute name"), this.state = E.ATTRIB)
                            }
                            continue;
                        case E.ATTRIB_VALUE:
                            if (f(r)) continue;
                            g(r) ? (this.q = r, this.state = E.ATTRIB_VALUE_QUOTED) : (R(this, "Unquoted attribute value"), this.state = E.ATTRIB_VALUE_UNQUOTED, this.attribValue = r);
                            continue;
                        case E.ATTRIB_VALUE_QUOTED:
                            if (r !== this.q) {
                                "&" === r ? this.state = E.ATTRIB_VALUE_ENTITY_Q : this.attribValue += r;
                                continue
                            }
                            _(this), this.q = "", this.state = E.ATTRIB_VALUE_CLOSED;
                            continue;
                        case E.ATTRIB_VALUE_CLOSED:
                            f(r) ? this.state = E.ATTRIB : ">" === r ? M(this) : "/" === r ? this.state = E.OPEN_TAG_SLASH : m(c, r) ? (R(this, "No whitespace between attributes"), this.attribName = r, this.attribValue = "", this.state = E.ATTRIB_NAME) : R(this, "Invalid attribute name");
                            continue;
                        case E.ATTRIB_VALUE_UNQUOTED:
                            if (!v(r)) {
                                "&" === r ? this.state = E.ATTRIB_VALUE_ENTITY_U : this.attribValue += r;
                                continue
                            }
                            _(this), ">" === r ? M(this) : this.state = E.ATTRIB;
                            continue;
                        case E.CLOSE_TAG:
                            if (this.tagName) ">" === r ? B(this) : m(u, r) ? this.tagName += r : this.script ? (this.script += "</" + this.tagName, this.tagName = "", this.state = E.SCRIPT) : (f(r) || R(this, "Invalid tagname in closing tag"), this.state = E.CLOSE_TAG_SAW_WHITE); else {
                                if (f(r)) continue;
                                y(c, r) ? this.script ? (this.script += "</" + r, this.state = E.SCRIPT) : R(this, "Invalid tagname in closing tag.") : this.tagName = r
                            }
                            continue;
                        case E.CLOSE_TAG_SAW_WHITE:
                            if (f(r)) continue;
                            ">" === r ? B(this) : R(this, "Invalid characters in closing tag");
                            continue;
                        case E.TEXT_ENTITY:
                        case E.ATTRIB_VALUE_ENTITY_Q:
                        case E.ATTRIB_VALUE_ENTITY_U:
                            var o, l;
                            switch (this.state) {
                                case E.TEXT_ENTITY:
                                    o = E.TEXT, l = "textNode";
                                    break;
                                case E.ATTRIB_VALUE_ENTITY_Q:
                                    o = E.ATTRIB_VALUE_QUOTED, l = "attribValue";
                                    break;
                                case E.ATTRIB_VALUE_ENTITY_U:
                                    o = E.ATTRIB_VALUE_UNQUOTED, l = "attribValue"
                            }
                            ";" === r ? (this[l] += U(this), this.entity = "", this.state = o) : m(this.entity.length ? p : d, r) ? this.entity += r : (R(this, "Invalid character in entity name"), this[l] += "&" + this.entity + r, this.entity = "", this.state = o);
                            continue;
                        default:
                            throw new Error(this, "Unknown state: " + this.state)
                    }
                    this.position >= this.bufferCheckPosition && function (t) {
                        for (var i = Math.max(e.MAX_BUFFER_LENGTH, 10), r = 0, s = 0, a = n.length; s < a; s++) {
                            var o = t[n[s]].length;
                            if (o > i) switch (n[s]) {
                                case"textNode":
                                    C(t);
                                    break;
                                case"cdata":
                                    S(t, "oncdata", t.cdata), t.cdata = "";
                                    break;
                                case"script":
                                    S(t, "onscript", t.script), t.script = "";
                                    break;
                                default:
                                    D(t, "Max buffer length exceeded: " + n[s])
                            }
                            r = Math.max(r, o)
                        }
                        var l = e.MAX_BUFFER_LENGTH - r;
                        t.bufferCheckPosition = l + t.position
                    }(this);
                    return this
                }
                /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */, resume: function () {
                    return this.error = null, this
                }, close: function () {
                    return this.write(null)
                }, flush: function () {
                    var t;
                    C(t = this), "" !== t.cdata && (S(t, "oncdata", t.cdata), t.cdata = ""), "" !== t.script && (S(t, "onscript", t.script), t.script = "")
                }
            };
            try {
                r = i(22).Stream
            } catch (t) {
                r = function () {
                }
            }
            var a = e.EVENTS.filter((function (t) {
                return "error" !== t && "end" !== t
            }));

            function o(t, e) {
                if (!(this instanceof o)) return new o(t, e);
                r.apply(this), this._parser = new s(t, e), this.writable = !0, this.readable = !0;
                var i = this;
                this._parser.onend = function () {
                    i.emit("end")
                }, this._parser.onerror = function (t) {
                    i.emit("error", t), i._parser.error = null
                }, this._decoder = null, a.forEach((function (t) {
                    Object.defineProperty(i, "on" + t, {
                        get: function () {
                            return i._parser["on" + t]
                        }, set: function (e) {
                            if (!e) return i.removeAllListeners(t), i._parser["on" + t] = e, e;
                            i.on(t, e)
                        }, enumerable: !0, configurable: !1
                    })
                }))
            }

            o.prototype = Object.create(r.prototype, {constructor: {value: o}}), o.prototype.write = function (e) {
                if ("function" == typeof t && "function" == typeof t.isBuffer && t.isBuffer(e)) {
                    if (!this._decoder) {
                        var r = i(13).StringDecoder;
                        this._decoder = new r("utf8")
                    }
                    e = this._decoder.write(e)
                }
                return this._parser.write(e.toString()), this.emit("data", e), !0
            }, o.prototype.end = function (t) {
                return t && t.length && this.write(t), this._parser.end(), !0
            }, o.prototype.on = function (t, e) {
                var i = this;
                return i._parser["on" + t] || -1 === a.indexOf(t) || (i._parser["on" + t] = function () {
                    var e = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments);
                    e.splice(0, 0, t), i.emit.apply(i, e)
                }), r.prototype.on.call(i, t, e)
            };
            var l = "http://www.w3.org/XML/1998/namespace", h = {xml: l, xmlns: "http://www.w3.org/2000/xmlns/"},
                c = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
                u = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/,
                d = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
                p = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

            function f(t) {
                return " " === t || "\n" === t || "\r" === t || "\t" === t
            }

            function g(t) {
                return '"' === t || "'" === t
            }

            function v(t) {
                return ">" === t || f(t)
            }

            function m(t, e) {
                return t.test(e)
            }

            function y(t, e) {
                return !m(t, e)
            }

            var k, T, A, E = 0;
            for (var b in e.STATE = {
                BEGIN: E++,
                BEGIN_WHITESPACE: E++,
                TEXT: E++,
                TEXT_ENTITY: E++,
                OPEN_WAKA: E++,
                SGML_DECL: E++,
                SGML_DECL_QUOTED: E++,
                DOCTYPE: E++,
                DOCTYPE_QUOTED: E++,
                DOCTYPE_DTD: E++,
                DOCTYPE_DTD_QUOTED: E++,
                COMMENT_STARTING: E++,
                COMMENT: E++,
                COMMENT_ENDING: E++,
                COMMENT_ENDED: E++,
                CDATA: E++,
                CDATA_ENDING: E++,
                CDATA_ENDING_2: E++,
                PROC_INST: E++,
                PROC_INST_BODY: E++,
                PROC_INST_ENDING: E++,
                OPEN_TAG: E++,
                OPEN_TAG_SLASH: E++,
                ATTRIB: E++,
                ATTRIB_NAME: E++,
                ATTRIB_NAME_SAW_WHITE: E++,
                ATTRIB_VALUE: E++,
                ATTRIB_VALUE_QUOTED: E++,
                ATTRIB_VALUE_CLOSED: E++,
                ATTRIB_VALUE_UNQUOTED: E++,
                ATTRIB_VALUE_ENTITY_Q: E++,
                ATTRIB_VALUE_ENTITY_U: E++,
                CLOSE_TAG: E++,
                CLOSE_TAG_SAW_WHITE: E++,
                SCRIPT: E++,
                SCRIPT_ENDING: E++
            }, e.XML_ENTITIES = {amp: "&", gt: ">", lt: "<", quot: '"', apos: "'"}, e.ENTITIES = {
                amp: "&",
                gt: ">",
                lt: "<",
                quot: '"',
                apos: "'",
                AElig: 198,
                Aacute: 193,
                Acirc: 194,
                Agrave: 192,
                Aring: 197,
                Atilde: 195,
                Auml: 196,
                Ccedil: 199,
                ETH: 208,
                Eacute: 201,
                Ecirc: 202,
                Egrave: 200,
                Euml: 203,
                Iacute: 205,
                Icirc: 206,
                Igrave: 204,
                Iuml: 207,
                Ntilde: 209,
                Oacute: 211,
                Ocirc: 212,
                Ograve: 210,
                Oslash: 216,
                Otilde: 213,
                Ouml: 214,
                THORN: 222,
                Uacute: 218,
                Ucirc: 219,
                Ugrave: 217,
                Uuml: 220,
                Yacute: 221,
                aacute: 225,
                acirc: 226,
                aelig: 230,
                agrave: 224,
                aring: 229,
                atilde: 227,
                auml: 228,
                ccedil: 231,
                eacute: 233,
                ecirc: 234,
                egrave: 232,
                eth: 240,
                euml: 235,
                iacute: 237,
                icirc: 238,
                igrave: 236,
                iuml: 239,
                ntilde: 241,
                oacute: 243,
                ocirc: 244,
                ograve: 242,
                oslash: 248,
                otilde: 245,
                ouml: 246,
                szlig: 223,
                thorn: 254,
                uacute: 250,
                ucirc: 251,
                ugrave: 249,
                uuml: 252,
                yacute: 253,
                yuml: 255,
                copy: 169,
                reg: 174,
                nbsp: 160,
                iexcl: 161,
                cent: 162,
                pound: 163,
                curren: 164,
                yen: 165,
                brvbar: 166,
                sect: 167,
                uml: 168,
                ordf: 170,
                laquo: 171,
                not: 172,
                shy: 173,
                macr: 175,
                deg: 176,
                plusmn: 177,
                sup1: 185,
                sup2: 178,
                sup3: 179,
                acute: 180,
                micro: 181,
                para: 182,
                middot: 183,
                cedil: 184,
                ordm: 186,
                raquo: 187,
                frac14: 188,
                frac12: 189,
                frac34: 190,
                iquest: 191,
                times: 215,
                divide: 247,
                OElig: 338,
                oelig: 339,
                Scaron: 352,
                scaron: 353,
                Yuml: 376,
                fnof: 402,
                circ: 710,
                tilde: 732,
                Alpha: 913,
                Beta: 914,
                Gamma: 915,
                Delta: 916,
                Epsilon: 917,
                Zeta: 918,
                Eta: 919,
                Theta: 920,
                Iota: 921,
                Kappa: 922,
                Lambda: 923,
                Mu: 924,
                Nu: 925,
                Xi: 926,
                Omicron: 927,
                Pi: 928,
                Rho: 929,
                Sigma: 931,
                Tau: 932,
                Upsilon: 933,
                Phi: 934,
                Chi: 935,
                Psi: 936,
                Omega: 937,
                alpha: 945,
                beta: 946,
                gamma: 947,
                delta: 948,
                epsilon: 949,
                zeta: 950,
                eta: 951,
                theta: 952,
                iota: 953,
                kappa: 954,
                lambda: 955,
                mu: 956,
                nu: 957,
                xi: 958,
                omicron: 959,
                pi: 960,
                rho: 961,
                sigmaf: 962,
                sigma: 963,
                tau: 964,
                upsilon: 965,
                phi: 966,
                chi: 967,
                psi: 968,
                omega: 969,
                thetasym: 977,
                upsih: 978,
                piv: 982,
                ensp: 8194,
                emsp: 8195,
                thinsp: 8201,
                zwnj: 8204,
                zwj: 8205,
                lrm: 8206,
                rlm: 8207,
                ndash: 8211,
                mdash: 8212,
                lsquo: 8216,
                rsquo: 8217,
                sbquo: 8218,
                ldquo: 8220,
                rdquo: 8221,
                bdquo: 8222,
                dagger: 8224,
                Dagger: 8225,
                bull: 8226,
                hellip: 8230,
                permil: 8240,
                prime: 8242,
                Prime: 8243,
                lsaquo: 8249,
                rsaquo: 8250,
                oline: 8254,
                frasl: 8260,
                euro: 8364,
                image: 8465,
                weierp: 8472,
                real: 8476,
                trade: 8482,
                alefsym: 8501,
                larr: 8592,
                uarr: 8593,
                rarr: 8594,
                darr: 8595,
                harr: 8596,
                crarr: 8629,
                lArr: 8656,
                uArr: 8657,
                rArr: 8658,
                dArr: 8659,
                hArr: 8660,
                forall: 8704,
                part: 8706,
                exist: 8707,
                empty: 8709,
                nabla: 8711,
                isin: 8712,
                notin: 8713,
                ni: 8715,
                prod: 8719,
                sum: 8721,
                minus: 8722,
                lowast: 8727,
                radic: 8730,
                prop: 8733,
                infin: 8734,
                ang: 8736,
                and: 8743,
                or: 8744,
                cap: 8745,
                cup: 8746,
                int: 8747,
                there4: 8756,
                sim: 8764,
                cong: 8773,
                asymp: 8776,
                ne: 8800,
                equiv: 8801,
                le: 8804,
                ge: 8805,
                sub: 8834,
                sup: 8835,
                nsub: 8836,
                sube: 8838,
                supe: 8839,
                oplus: 8853,
                otimes: 8855,
                perp: 8869,
                sdot: 8901,
                lceil: 8968,
                rceil: 8969,
                lfloor: 8970,
                rfloor: 8971,
                lang: 9001,
                rang: 9002,
                loz: 9674,
                spades: 9824,
                clubs: 9827,
                hearts: 9829,
                diams: 9830
            }, Object.keys(e.ENTITIES).forEach((function (t) {
                var i = e.ENTITIES[t], r = "number" == typeof i ? String.fromCharCode(i) : i;
                e.ENTITIES[t] = r
            })), e.STATE) e.STATE[e.STATE[b]] = b;

            function w(t, e, i) {
                t[e] && t[e](i)
            }

            function S(t, e, i) {
                t.textNode && C(t), w(t, e, i)
            }

            function C(t) {
                t.textNode = I(t.opt, t.textNode), t.textNode && w(t, "ontext", t.textNode), t.textNode = ""
            }

            function I(t, e) {
                return t.trim && (e = e.trim()), t.normalize && (e = e.replace(/\s+/g, " ")), e
            }

            function D(t, e) {
                return C(t), t.trackPosition && (e += "\nLine: " + t.line + "\nColumn: " + t.column + "\nChar: " + t.c), e = new Error(e), t.error = e, w(t, "onerror", e), t
            }

            function P(t) {
                return t.sawRoot && !t.closedRoot && R(t, "Unclosed root tag"), t.state !== E.BEGIN && t.state !== E.BEGIN_WHITESPACE && t.state !== E.TEXT && D(t, "Unexpected end"), C(t), t.c = "", t.closed = !0, w(t, "onend"), s.call(t, t.strict, t.opt), t
            }

            function R(t, e) {
                if ("object" != typeof t || !(t instanceof s)) throw new Error("bad call to strictFail");
                t.strict && D(t, e)
            }

            function L(t) {
                t.strict || (t.tagName = t.tagName[t.looseCase]());
                var e = t.tags[t.tags.length - 1] || t, i = t.tag = {name: t.tagName, attributes: {}};
                t.opt.xmlns && (i.ns = e.ns), t.attribList.length = 0, S(t, "onopentagstart", i)
            }

            function N(t, e) {
                var i = t.indexOf(":") < 0 ? ["", t] : t.split(":"), r = i[0], n = i[1];
                return e && "xmlns" === t && (r = "xmlns", n = ""), {prefix: r, local: n}
            }

            function _(t) {
                if (t.strict || (t.attribName = t.attribName[t.looseCase]()), -1 !== t.attribList.indexOf(t.attribName) || t.tag.attributes.hasOwnProperty(t.attribName)) t.attribName = t.attribValue = ""; else {
                    if (t.opt.xmlns) {
                        var e = N(t.attribName, !0), i = e.prefix, r = e.local;
                        if ("xmlns" === i) if ("xml" === r && t.attribValue !== l) R(t, "xml: prefix must be bound to " + l + "\nActual: " + t.attribValue); else if ("xmlns" === r && "http://www.w3.org/2000/xmlns/" !== t.attribValue) R(t, "xmlns: prefix must be bound to http://www.w3.org/2000/xmlns/\nActual: " + t.attribValue); else {
                            var n = t.tag, s = t.tags[t.tags.length - 1] || t;
                            n.ns === s.ns && (n.ns = Object.create(s.ns)), n.ns[r] = t.attribValue
                        }
                        t.attribList.push([t.attribName, t.attribValue])
                    } else t.tag.attributes[t.attribName] = t.attribValue, S(t, "onattribute", {
                        name: t.attribName,
                        value: t.attribValue
                    });
                    t.attribName = t.attribValue = ""
                }
            }

            function M(t, e) {
                if (t.opt.xmlns) {
                    var i = t.tag, r = N(t.tagName);
                    i.prefix = r.prefix, i.local = r.local, i.uri = i.ns[r.prefix] || "", i.prefix && !i.uri && (R(t, "Unbound namespace prefix: " + JSON.stringify(t.tagName)), i.uri = r.prefix);
                    var n = t.tags[t.tags.length - 1] || t;
                    i.ns && n.ns !== i.ns && Object.keys(i.ns).forEach((function (e) {
                        S(t, "onopennamespace", {prefix: e, uri: i.ns[e]})
                    }));
                    for (var s = 0, a = t.attribList.length; s < a; s++) {
                        var o = t.attribList[s], l = o[0], h = o[1], c = N(l, !0), u = c.prefix, d = c.local,
                            p = "" === u ? "" : i.ns[u] || "", f = {name: l, value: h, prefix: u, local: d, uri: p};
                        u && "xmlns" !== u && !p && (R(t, "Unbound namespace prefix: " + JSON.stringify(u)), f.uri = u), t.tag.attributes[l] = f, S(t, "onattribute", f)
                    }
                    t.attribList.length = 0
                }
                t.tag.isSelfClosing = !!e, t.sawRoot = !0, t.tags.push(t.tag), S(t, "onopentag", t.tag), e || (t.noscript || "script" !== t.tagName.toLowerCase() ? t.state = E.TEXT : t.state = E.SCRIPT, t.tag = null, t.tagName = ""), t.attribName = t.attribValue = "", t.attribList.length = 0
            }

            function B(t) {
                if (!t.tagName) return R(t, "Weird empty close tag."), t.textNode += "</>", void (t.state = E.TEXT);
                if (t.script) {
                    if ("script" !== t.tagName) return t.script += "</" + t.tagName + ">", t.tagName = "", void (t.state = E.SCRIPT);
                    S(t, "onscript", t.script), t.script = ""
                }
                var e = t.tags.length, i = t.tagName;
                t.strict || (i = i[t.looseCase]());
                for (var r = i; e--;) {
                    if (t.tags[e].name === r) break;
                    R(t, "Unexpected close tag")
                }
                if (e < 0) return R(t, "Unmatched closing tag: " + t.tagName), t.textNode += "</" + t.tagName + ">", void (t.state = E.TEXT);
                t.tagName = i;
                for (var n = t.tags.length; n-- > e;) {
                    var s = t.tag = t.tags.pop();
                    t.tagName = t.tag.name, S(t, "onclosetag", t.tagName);
                    var a = {};
                    for (var o in s.ns) a[o] = s.ns[o];
                    var l = t.tags[t.tags.length - 1] || t;
                    t.opt.xmlns && s.ns !== l.ns && Object.keys(s.ns).forEach((function (e) {
                        var i = s.ns[e];
                        S(t, "onclosenamespace", {prefix: e, uri: i})
                    }))
                }
                0 === e && (t.closedRoot = !0), t.tagName = t.attribValue = t.attribName = "", t.attribList.length = 0, t.state = E.TEXT
            }

            function U(t) {
                var e, i = t.entity, r = i.toLowerCase(), n = "";
                return t.ENTITIES[i] ? t.ENTITIES[i] : t.ENTITIES[r] ? t.ENTITIES[r] : ("#" === (i = r).charAt(0) && ("x" === i.charAt(1) ? (i = i.slice(2), n = (e = parseInt(i, 16)).toString(16)) : (i = i.slice(1), n = (e = parseInt(i, 10)).toString(10))), i = i.replace(/^0+/, ""), isNaN(e) || n.toLowerCase() !== i ? (R(t, "Invalid character entity"), "&" + t.entity + ";") : String.fromCodePoint(e))
            }

            function x(t, e) {
                "<" === e ? (t.state = E.OPEN_WAKA, t.startTagPosition = t.position) : f(e) || (R(t, "Non-whitespace before first tag."), t.textNode = e, t.state = E.TEXT)
            }

            function O(t, e) {
                var i = "";
                return e < t.length && (i = t.charAt(e)), i
            }

            E = e.STATE, String.fromCodePoint || (k = String.fromCharCode, T = Math.floor, A = function () {
                var t, e, i = 16384, r = [], n = -1, s = arguments.length;
                if (!s) return "";
                for (var a = ""; ++n < s;) {
                    var o = Number(arguments[n]);
                    if (!isFinite(o) || o < 0 || o > 1114111 || T(o) !== o) throw RangeError("Invalid code point: " + o);
                    o <= 65535 ? r.push(o) : (t = 55296 + ((o -= 65536) >> 10), e = o % 1024 + 56320, r.push(t, e)), (n + 1 === s || r.length > i) && (a += k.apply(null, r), r.length = 0)
                }
                return a
            }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
                value: A,
                configurable: !0,
                writable: !0
            }) : String.fromCodePoint = A)
        }(e)
    }).call(this, i(6).Buffer)
}, function (t, e, i) {
    "use strict";
    var r, n = "object" == typeof Reflect ? Reflect : null,
        s = n && "function" == typeof n.apply ? n.apply : function (t, e, i) {
            return Function.prototype.apply.call(t, e, i)
        };
    r = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function (t) {
        return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
    } : function (t) {
        return Object.getOwnPropertyNames(t)
    };
    var a = Number.isNaN || function (t) {
        return t != t
    };

    function o() {
        o.init.call(this)
    }

    t.exports = o, t.exports.once = function (t, e) {
        return new Promise((function (i, r) {
            function n(i) {
                t.removeListener(e, s), r(i)
            }

            function s() {
                "function" == typeof t.removeListener && t.removeListener("error", n), i([].slice.call(arguments))
            }

            m(t, e, s, {once: !0}), "error" !== e && function (t, e, i) {
                "function" == typeof t.on && m(t, "error", e, i)
            }(t, n, {once: !0})
        }))
    }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    var l = 10;

    function h(t) {
        if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
    }

    function c(t) {
        return void 0 === t._maxListeners ? o.defaultMaxListeners : t._maxListeners
    }

    function u(t, e, i, r) {
        var n, s, a, o;
        if (h(i), void 0 === (s = t._events) ? (s = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== s.newListener && (t.emit("newListener", e, i.listener ? i.listener : i), s = t._events), a = s[e]), void 0 === a) a = s[e] = i, ++t._eventsCount; else if ("function" == typeof a ? a = s[e] = r ? [i, a] : [a, i] : r ? a.unshift(i) : a.push(i), (n = c(t)) > 0 && a.length > n && !a.warned) {
            a.warned = !0;
            var l = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            l.name = "MaxListenersExceededWarning", l.emitter = t, l.type = e, l.count = a.length, o = l, console && console.warn && console.warn(o)
        }
        return t
    }

    function d() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function p(t, e, i) {
        var r = {fired: !1, wrapFn: void 0, target: t, type: e, listener: i}, n = d.bind(r);
        return n.listener = i, r.wrapFn = n, n
    }

    function f(t, e, i) {
        var r = t._events;
        if (void 0 === r) return [];
        var n = r[e];
        return void 0 === n ? [] : "function" == typeof n ? i ? [n.listener || n] : [n] : i ? function (t) {
            for (var e = new Array(t.length), i = 0; i < e.length; ++i) e[i] = t[i].listener || t[i];
            return e
        }(n) : v(n, n.length)
    }

    function g(t) {
        var e = this._events;
        if (void 0 !== e) {
            var i = e[t];
            if ("function" == typeof i) return 1;
            if (void 0 !== i) return i.length
        }
        return 0
    }

    function v(t, e) {
        for (var i = new Array(e), r = 0; r < e; ++r) i[r] = t[r];
        return i
    }

    function m(t, e, i, r) {
        if ("function" == typeof t.on) r.once ? t.once(e, i) : t.on(e, i); else {
            if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
            t.addEventListener(e, (function n(s) {
                r.once && t.removeEventListener(e, n), i(s)
            }))
        }
    }

    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0, get: function () {
            return l
        }, set: function (t) {
            if ("number" != typeof t || t < 0 || a(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            l = t
        }
    }), o.init = function () {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    }, o.prototype.setMaxListeners = function (t) {
        if ("number" != typeof t || t < 0 || a(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
        return this._maxListeners = t, this
    }, o.prototype.getMaxListeners = function () {
        return c(this)
    }, o.prototype.emit = function (t) {
        for (var e = [], i = 1; i < arguments.length; i++) e.push(arguments[i]);
        var r = "error" === t, n = this._events;
        if (void 0 !== n) r = r && void 0 === n.error; else if (!r) return !1;
        if (r) {
            var a;
            if (e.length > 0 && (a = e[0]), a instanceof Error) throw a;
            var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw o.context = a, o
        }
        var l = n[t];
        if (void 0 === l) return !1;
        if ("function" == typeof l) s(l, this, e); else {
            var h = l.length, c = v(l, h);
            for (i = 0; i < h; ++i) s(c[i], this, e)
        }
        return !0
    }, o.prototype.addListener = function (t, e) {
        return u(this, t, e, !1)
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (t, e) {
        return u(this, t, e, !0)
    }, o.prototype.once = function (t, e) {
        return h(e), this.on(t, p(this, t, e)), this
    }, o.prototype.prependOnceListener = function (t, e) {
        return h(e), this.prependListener(t, p(this, t, e)), this
    }, o.prototype.removeListener = function (t, e) {
        var i, r, n, s, a;
        if (h(e), void 0 === (r = this._events)) return this;
        if (void 0 === (i = r[t])) return this;
        if (i === e || i.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, i.listener || e)); else if ("function" != typeof i) {
            for (n = -1, s = i.length - 1; s >= 0; s--) if (i[s] === e || i[s].listener === e) {
                a = i[s].listener, n = s;
                break
            }
            if (n < 0) return this;
            0 === n ? i.shift() : function (t, e) {
                for (; e + 1 < t.length; e++) t[e] = t[e + 1];
                t.pop()
            }(i, n), 1 === i.length && (r[t] = i[0]), void 0 !== r.removeListener && this.emit("removeListener", t, a || e)
        }
        return this
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (t) {
        var e, i, r;
        if (void 0 === (i = this._events)) return this;
        if (void 0 === i.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== i[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete i[t]), this;
        if (0 === arguments.length) {
            var n, s = Object.keys(i);
            for (r = 0; r < s.length; ++r) "removeListener" !== (n = s[r]) && this.removeAllListeners(n);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if ("function" == typeof (e = i[t])) this.removeListener(t, e); else if (void 0 !== e) for (r = e.length - 1; r >= 0; r--) this.removeListener(t, e[r]);
        return this
    }, o.prototype.listeners = function (t) {
        return f(this, t, !0)
    }, o.prototype.rawListeners = function (t) {
        return f(this, t, !1)
    }, o.listenerCount = function (t, e) {
        return "function" == typeof t.listenerCount ? t.listenerCount(e) : g.call(t, e)
    }, o.prototype.listenerCount = g, o.prototype.eventNames = function () {
        return this._eventsCount > 0 ? r(this._events) : []
    }
}, function (t, e, i) {
    (e = t.exports = i(14)).Stream = e, e.Readable = e, e.Writable = i(12), e.Duplex = i(1), e.Transform = i(17), e.PassThrough = i(31)
}, function (t, e, i) {
    var r = i(6), n = r.Buffer;

    function s(t, e) {
        for (var i in t) e[i] = t[i]
    }

    function a(t, e, i) {
        return n(t, e, i)
    }

    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (s(r, e), e.Buffer = a), s(n, a), a.from = function (t, e, i) {
        if ("number" == typeof t) throw new TypeError("Argument must not be a number");
        return n(t, e, i)
    }, a.alloc = function (t, e, i) {
        if ("number" != typeof t) throw new TypeError("Argument must be a number");
        var r = n(t);
        return void 0 !== e ? "string" == typeof i ? r.fill(e, i) : r.fill(e) : r.fill(0), r
    }, a.allocUnsafe = function (t) {
        if ("number" != typeof t) throw new TypeError("Argument must be a number");
        return n(t)
    }, a.allocUnsafeSlow = function (t) {
        if ("number" != typeof t) throw new TypeError("Argument must be a number");
        return r.SlowBuffer(t)
    }
}, function (t, e, i) {
    "use strict";
    (function (e, r, n) {
        var s = i(7);

        function a(t) {
            var e = this;
            this.next = null, this.entry = null, this.finish = function () {
                !function (t, e, i) {
                    var r = t.entry;
                    t.entry = null;
                    for (; r;) {
                        var n = r.callback;
                        e.pendingcb--, n(i), r = r.next
                    }
                    e.corkedRequestsFree ? e.corkedRequestsFree.next = t : e.corkedRequestsFree = t
                }(e, t)
            }
        }

        t.exports = y;
        var o, l = !e.browser && ["v0.10", "v0.9."].indexOf(e.version.slice(0, 5)) > -1 ? r : s.nextTick;
        y.WritableState = m;
        var h = Object.create(i(5));
        h.inherits = i(3);
        var c = {deprecate: i(29)}, u = i(15), d = i(11).Buffer, p = n.Uint8Array || function () {
        };
        var f, g = i(16);

        function v() {
        }

        function m(t, e) {
            o = o || i(1), t = t || {};
            var r = e instanceof o;
            this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode);
            var n = t.highWaterMark, h = t.writableHighWaterMark, c = this.objectMode ? 16 : 16384;
            this.highWaterMark = n || 0 === n ? n : r && (h || 0 === h) ? h : c, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var u = !1 === t.decodeStrings;
            this.decodeStrings = !u, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (t) {
                !function (t, e) {
                    var i = t._writableState, r = i.sync, n = i.writecb;
                    if (function (t) {
                        t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0
                    }(i), e) !function (t, e, i, r, n) {
                        --e.pendingcb, i ? (s.nextTick(n, r), s.nextTick(w, t, e), t._writableState.errorEmitted = !0, t.emit("error", r)) : (n(r), t._writableState.errorEmitted = !0, t.emit("error", r), w(t, e))
                    }(t, i, r, e, n); else {
                        var a = E(i);
                        a || i.corked || i.bufferProcessing || !i.bufferedRequest || A(t, i), r ? l(T, t, i, a, n) : T(t, i, a, n)
                    }
                }(e, t)
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this)
        }

        function y(t) {
            if (o = o || i(1), !(f.call(y, this) || this instanceof o)) return new y(t);
            this._writableState = new m(t, this), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), u.call(this)
        }

        function k(t, e, i, r, n, s, a) {
            e.writelen = r, e.writecb = a, e.writing = !0, e.sync = !0, i ? t._writev(n, e.onwrite) : t._write(n, s, e.onwrite), e.sync = !1
        }

        function T(t, e, i, r) {
            i || function (t, e) {
                0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain"))
            }(t, e), e.pendingcb--, r(), w(t, e)
        }

        function A(t, e) {
            e.bufferProcessing = !0;
            var i = e.bufferedRequest;
            if (t._writev && i && i.next) {
                var r = e.bufferedRequestCount, n = new Array(r), s = e.corkedRequestsFree;
                s.entry = i;
                for (var o = 0, l = !0; i;) n[o] = i, i.isBuf || (l = !1), i = i.next, o += 1;
                n.allBuffers = l, k(t, e, !0, e.length, n, "", s.finish), e.pendingcb++, e.lastBufferedRequest = null, s.next ? (e.corkedRequestsFree = s.next, s.next = null) : e.corkedRequestsFree = new a(e), e.bufferedRequestCount = 0
            } else {
                for (; i;) {
                    var h = i.chunk, c = i.encoding, u = i.callback;
                    if (k(t, e, !1, e.objectMode ? 1 : h.length, h, c, u), i = i.next, e.bufferedRequestCount--, e.writing) break
                }
                null === i && (e.lastBufferedRequest = null)
            }
            e.bufferedRequest = i, e.bufferProcessing = !1
        }

        function E(t) {
            return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing
        }

        function b(t, e) {
            t._final((function (i) {
                e.pendingcb--, i && t.emit("error", i), e.prefinished = !0, t.emit("prefinish"), w(t, e)
            }))
        }

        function w(t, e) {
            var i = E(e);
            return i && (!function (t, e) {
                e.prefinished || e.finalCalled || ("function" == typeof t._final ? (e.pendingcb++, e.finalCalled = !0, s.nextTick(b, t, e)) : (e.prefinished = !0, t.emit("prefinish")))
            }(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"))), i
        }

        h.inherits(y, u), m.prototype.getBuffer = function () {
            for (var t = this.bufferedRequest, e = []; t;) e.push(t), t = t.next;
            return e
        }, function () {
            try {
                Object.defineProperty(m.prototype, "buffer", {
                    get: c.deprecate((function () {
                        return this.getBuffer()
                    }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                })
            } catch (t) {
            }
        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (f = Function.prototype[Symbol.hasInstance], Object.defineProperty(y, Symbol.hasInstance, {
            value: function (t) {
                return !!f.call(this, t) || this === y && (t && t._writableState instanceof m)
            }
        })) : f = function (t) {
            return t instanceof this
        }, y.prototype.pipe = function () {
            this.emit("error", new Error("Cannot pipe, not readable"))
        }, y.prototype.write = function (t, e, i) {
            var r, n = this._writableState, a = !1, o = !n.objectMode && (r = t, d.isBuffer(r) || r instanceof p);
            return o && !d.isBuffer(t) && (t = function (t) {
                return d.from(t)
            }(t)), "function" == typeof e && (i = e, e = null), o ? e = "buffer" : e || (e = n.defaultEncoding), "function" != typeof i && (i = v), n.ended ? function (t, e) {
                var i = new Error("write after end");
                t.emit("error", i), s.nextTick(e, i)
            }(this, i) : (o || function (t, e, i, r) {
                var n = !0, a = !1;
                return null === i ? a = new TypeError("May not write null values to stream") : "string" == typeof i || void 0 === i || e.objectMode || (a = new TypeError("Invalid non-string/buffer chunk")), a && (t.emit("error", a), s.nextTick(r, a), n = !1), n
            }(this, n, t, i)) && (n.pendingcb++, a = function (t, e, i, r, n, s) {
                if (!i) {
                    var a = function (t, e, i) {
                        t.objectMode || !1 === t.decodeStrings || "string" != typeof e || (e = d.from(e, i));
                        return e
                    }(e, r, n);
                    r !== a && (i = !0, n = "buffer", r = a)
                }
                var o = e.objectMode ? 1 : r.length;
                e.length += o;
                var l = e.length < e.highWaterMark;
                l || (e.needDrain = !0);
                if (e.writing || e.corked) {
                    var h = e.lastBufferedRequest;
                    e.lastBufferedRequest = {
                        chunk: r,
                        encoding: n,
                        isBuf: i,
                        callback: s,
                        next: null
                    }, h ? h.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1
                } else k(t, e, !1, o, r, n, s);
                return l
            }(this, n, o, t, e, i)), a
        }, y.prototype.cork = function () {
            this._writableState.corked++
        }, y.prototype.uncork = function () {
            var t = this._writableState;
            t.corked && (t.corked--, t.writing || t.corked || t.finished || t.bufferProcessing || !t.bufferedRequest || A(this, t))
        }, y.prototype.setDefaultEncoding = function (t) {
            if ("string" == typeof t && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
            return this._writableState.defaultEncoding = t, this
        }, Object.defineProperty(y.prototype, "writableHighWaterMark", {
            enumerable: !1, get: function () {
                return this._writableState.highWaterMark
            }
        }), y.prototype._write = function (t, e, i) {
            i(new Error("_write() is not implemented"))
        }, y.prototype._writev = null, y.prototype.end = function (t, e, i) {
            var r = this._writableState;
            "function" == typeof t ? (i = t, t = null, e = null) : "function" == typeof e && (i = e, e = null), null != t && this.write(t, e), r.corked && (r.corked = 1, this.uncork()), r.ending || r.finished || function (t, e, i) {
                e.ending = !0, w(t, e), i && (e.finished ? s.nextTick(i) : t.once("finish", i));
                e.ended = !0, t.writable = !1
            }(this, r, i)
        }, Object.defineProperty(y.prototype, "destroyed", {
            get: function () {
                return void 0 !== this._writableState && this._writableState.destroyed
            }, set: function (t) {
                this._writableState && (this._writableState.destroyed = t)
            }
        }), y.prototype.destroy = g.destroy, y.prototype._undestroy = g.undestroy, y.prototype._destroy = function (t, e) {
            this.end(), e(t)
        }
    }).call(this, i(4), i(27).setImmediate, i(2))
}, function (t, e, i) {
    "use strict";
    var r = i(30).Buffer, n = r.isEncoding || function (t) {
        switch ((t = "" + t) && t.toLowerCase()) {
            case"hex":
            case"utf8":
            case"utf-8":
            case"ascii":
            case"binary":
            case"base64":
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
            case"raw":
                return !0;
            default:
                return !1
        }
    };

    function s(t) {
        var e;
        switch (this.encoding = function (t) {
            var e = function (t) {
                if (!t) return "utf8";
                for (var e; ;) switch (t) {
                    case"utf8":
                    case"utf-8":
                        return "utf8";
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return "utf16le";
                    case"latin1":
                    case"binary":
                        return "latin1";
                    case"base64":
                    case"ascii":
                    case"hex":
                        return t;
                    default:
                        if (e) return;
                        t = ("" + t).toLowerCase(), e = !0
                }
            }(t);
            if ("string" != typeof e && (r.isEncoding === n || !n(t))) throw new Error("Unknown encoding: " + t);
            return e || t
        }(t), this.encoding) {
            case"utf16le":
                this.text = l, this.end = h, e = 4;
                break;
            case"utf8":
                this.fillLast = o, e = 4;
                break;
            case"base64":
                this.text = c, this.end = u, e = 3;
                break;
            default:
                return this.write = d, void (this.end = p)
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(e)
    }

    function a(t) {
        return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2
    }

    function o(t) {
        var e = this.lastTotal - this.lastNeed, i = function (t, e, i) {
            if (128 != (192 & e[0])) return t.lastNeed = 0, "";
            if (t.lastNeed > 1 && e.length > 1) {
                if (128 != (192 & e[1])) return t.lastNeed = 1, "";
                if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, ""
            }
        }(this, t);
        return void 0 !== i ? i : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void (this.lastNeed -= t.length))
    }

    function l(t, e) {
        if ((t.length - e) % 2 == 0) {
            var i = t.toString("utf16le", e);
            if (i) {
                var r = i.charCodeAt(i.length - 1);
                if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], i.slice(0, -1)
            }
            return i
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1)
    }

    function h(t) {
        var e = t && t.length ? this.write(t) : "";
        if (this.lastNeed) {
            var i = this.lastTotal - this.lastNeed;
            return e + this.lastChar.toString("utf16le", 0, i)
        }
        return e
    }

    function c(t, e) {
        var i = (t.length - e) % 3;
        return 0 === i ? t.toString("base64", e) : (this.lastNeed = 3 - i, this.lastTotal = 3, 1 === i ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - i))
    }

    function u(t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e
    }

    function d(t) {
        return t.toString(this.encoding)
    }

    function p(t) {
        return t && t.length ? this.write(t) : ""
    }

    e.StringDecoder = s, s.prototype.write = function (t) {
        if (0 === t.length) return "";
        var e, i;
        if (this.lastNeed) {
            if (void 0 === (e = this.fillLast(t))) return "";
            i = this.lastNeed, this.lastNeed = 0
        } else i = 0;
        return i < t.length ? e ? e + this.text(t, i) : this.text(t, i) : e || ""
    }, s.prototype.end = function (t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + "" : e
    }, s.prototype.text = function (t, e) {
        var i = function (t, e, i) {
            var r = e.length - 1;
            if (r < i) return 0;
            var n = a(e[r]);
            if (n >= 0) return n > 0 && (t.lastNeed = n - 1), n;
            if (--r < i || -2 === n) return 0;
            if ((n = a(e[r])) >= 0) return n > 0 && (t.lastNeed = n - 2), n;
            if (--r < i || -2 === n) return 0;
            if ((n = a(e[r])) >= 0) return n > 0 && (2 === n ? n = 0 : t.lastNeed = n - 3), n;
            return 0
        }(this, t, e);
        if (!this.lastNeed) return t.toString("utf8", e);
        this.lastTotal = i;
        var r = t.length - (i - this.lastNeed);
        return t.copy(this.lastChar, 0, r), t.toString("utf8", e, r)
    }, s.prototype.fillLast = function (t) {
        if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length
    }
}, function (t, e, i) {
    "use strict";
    (function (e, r) {
        var n = i(7);
        t.exports = k;
        var s, a = i(23);
        k.ReadableState = y;
        i(9).EventEmitter;
        var o = function (t, e) {
            return t.listeners(e).length
        }, l = i(15), h = i(11).Buffer, c = e.Uint8Array || function () {
        };
        var u = Object.create(i(5));
        u.inherits = i(3);
        var d = i(24), p = void 0;
        p = d && d.debuglog ? d.debuglog("stream") : function () {
        };
        var f, g = i(25), v = i(16);
        u.inherits(k, l);
        var m = ["error", "close", "destroy", "pause", "resume"];

        function y(t, e) {
            t = t || {};
            var r = e instanceof (s = s || i(1));
            this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode);
            var n = t.highWaterMark, a = t.readableHighWaterMark, o = this.objectMode ? 16 : 16384;
            this.highWaterMark = n || 0 === n ? n : r && (a || 0 === a) ? a : o, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new g, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (f || (f = i(13).StringDecoder), this.decoder = new f(t.encoding), this.encoding = t.encoding)
        }

        function k(t) {
            if (s = s || i(1), !(this instanceof k)) return new k(t);
            this._readableState = new y(t, this), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), l.call(this)
        }

        function T(t, e, i, r, n) {
            var s, a = t._readableState;
            null === e ? (a.reading = !1, function (t, e) {
                if (e.ended) return;
                if (e.decoder) {
                    var i = e.decoder.end();
                    i && i.length && (e.buffer.push(i), e.length += e.objectMode ? 1 : i.length)
                }
                e.ended = !0, b(t)
            }(t, a)) : (n || (s = function (t, e) {
                var i;
                r = e, h.isBuffer(r) || r instanceof c || "string" == typeof e || void 0 === e || t.objectMode || (i = new TypeError("Invalid non-string/buffer chunk"));
                var r;
                return i
            }(a, e)), s ? t.emit("error", s) : a.objectMode || e && e.length > 0 ? ("string" == typeof e || a.objectMode || Object.getPrototypeOf(e) === h.prototype || (e = function (t) {
                return h.from(t)
            }(e)), r ? a.endEmitted ? t.emit("error", new Error("stream.unshift() after end event")) : A(t, a, e, !0) : a.ended ? t.emit("error", new Error("stream.push() after EOF")) : (a.reading = !1, a.decoder && !i ? (e = a.decoder.write(e), a.objectMode || 0 !== e.length ? A(t, a, e, !1) : S(t, a)) : A(t, a, e, !1))) : r || (a.reading = !1));
            return function (t) {
                return !t.ended && (t.needReadable || t.length < t.highWaterMark || 0 === t.length)
            }(a)
        }

        function A(t, e, i, r) {
            e.flowing && 0 === e.length && !e.sync ? (t.emit("data", i), t.read(0)) : (e.length += e.objectMode ? 1 : i.length, r ? e.buffer.unshift(i) : e.buffer.push(i), e.needReadable && b(t)), S(t, e)
        }

        Object.defineProperty(k.prototype, "destroyed", {
            get: function () {
                return void 0 !== this._readableState && this._readableState.destroyed
            }, set: function (t) {
                this._readableState && (this._readableState.destroyed = t)
            }
        }), k.prototype.destroy = v.destroy, k.prototype._undestroy = v.undestroy, k.prototype._destroy = function (t, e) {
            this.push(null), e(t)
        }, k.prototype.push = function (t, e) {
            var i, r = this._readableState;
            return r.objectMode ? i = !0 : "string" == typeof t && ((e = e || r.defaultEncoding) !== r.encoding && (t = h.from(t, e), e = ""), i = !0), T(this, t, e, !1, i)
        }, k.prototype.unshift = function (t) {
            return T(this, t, null, !0, !1)
        }, k.prototype.isPaused = function () {
            return !1 === this._readableState.flowing
        }, k.prototype.setEncoding = function (t) {
            return f || (f = i(13).StringDecoder), this._readableState.decoder = new f(t), this._readableState.encoding = t, this
        };

        function E(t, e) {
            return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t != t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = function (t) {
                return t >= 8388608 ? t = 8388608 : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t
            }(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0))
        }

        function b(t) {
            var e = t._readableState;
            e.needReadable = !1, e.emittedReadable || (p("emitReadable", e.flowing), e.emittedReadable = !0, e.sync ? n.nextTick(w, t) : w(t))
        }

        function w(t) {
            p("emit readable"), t.emit("readable"), P(t)
        }

        function S(t, e) {
            e.readingMore || (e.readingMore = !0, n.nextTick(C, t, e))
        }

        function C(t, e) {
            for (var i = e.length; !e.reading && !e.flowing && !e.ended && e.length < e.highWaterMark && (p("maybeReadMore read 0"), t.read(0), i !== e.length);) i = e.length;
            e.readingMore = !1
        }

        function I(t) {
            p("readable nexttick read 0"), t.read(0)
        }

        function D(t, e) {
            e.reading || (p("resume read 0"), t.read(0)), e.resumeScheduled = !1, e.awaitDrain = 0, t.emit("resume"), P(t), e.flowing && !e.reading && t.read(0)
        }

        function P(t) {
            var e = t._readableState;
            for (p("flow", e.flowing); e.flowing && null !== t.read();) ;
        }

        function R(t, e) {
            return 0 === e.length ? null : (e.objectMode ? i = e.buffer.shift() : !t || t >= e.length ? (i = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.head.data : e.buffer.concat(e.length), e.buffer.clear()) : i = function (t, e, i) {
                var r;
                t < e.head.data.length ? (r = e.head.data.slice(0, t), e.head.data = e.head.data.slice(t)) : r = t === e.head.data.length ? e.shift() : i ? function (t, e) {
                    var i = e.head, r = 1, n = i.data;
                    t -= n.length;
                    for (; i = i.next;) {
                        var s = i.data, a = t > s.length ? s.length : t;
                        if (a === s.length ? n += s : n += s.slice(0, t), 0 === (t -= a)) {
                            a === s.length ? (++r, i.next ? e.head = i.next : e.head = e.tail = null) : (e.head = i, i.data = s.slice(a));
                            break
                        }
                        ++r
                    }
                    return e.length -= r, n
                }(t, e) : function (t, e) {
                    var i = h.allocUnsafe(t), r = e.head, n = 1;
                    r.data.copy(i), t -= r.data.length;
                    for (; r = r.next;) {
                        var s = r.data, a = t > s.length ? s.length : t;
                        if (s.copy(i, i.length - t, 0, a), 0 === (t -= a)) {
                            a === s.length ? (++n, r.next ? e.head = r.next : e.head = e.tail = null) : (e.head = r, r.data = s.slice(a));
                            break
                        }
                        ++n
                    }
                    return e.length -= n, i
                }(t, e);
                return r
            }(t, e.buffer, e.decoder), i);
            var i
        }

        function L(t) {
            var e = t._readableState;
            if (e.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            e.endEmitted || (e.ended = !0, n.nextTick(N, e, t))
        }

        function N(t, e) {
            t.endEmitted || 0 !== t.length || (t.endEmitted = !0, e.readable = !1, e.emit("end"))
        }

        function _(t, e) {
            for (var i = 0, r = t.length; i < r; i++) if (t[i] === e) return i;
            return -1
        }

        k.prototype.read = function (t) {
            p("read", t), t = parseInt(t, 10);
            var e = this._readableState, i = t;
            if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && (e.length >= e.highWaterMark || e.ended)) return p("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? L(this) : b(this), null;
            if (0 === (t = E(t, e)) && e.ended) return 0 === e.length && L(this), null;
            var r, n = e.needReadable;
            return p("need readable", n), (0 === e.length || e.length - t < e.highWaterMark) && p("length less than watermark", n = !0), e.ended || e.reading ? p("reading or ended", n = !1) : n && (p("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = E(i, e))), null === (r = t > 0 ? R(t, e) : null) ? (e.needReadable = !0, t = 0) : e.length -= t, 0 === e.length && (e.ended || (e.needReadable = !0), i !== t && e.ended && L(this)), null !== r && this.emit("data", r), r
        }, k.prototype._read = function (t) {
            this.emit("error", new Error("_read() is not implemented"))
        }, k.prototype.pipe = function (t, e) {
            var i = this, s = this._readableState;
            switch (s.pipesCount) {
                case 0:
                    s.pipes = t;
                    break;
                case 1:
                    s.pipes = [s.pipes, t];
                    break;
                default:
                    s.pipes.push(t)
            }
            s.pipesCount += 1, p("pipe count=%d opts=%j", s.pipesCount, e);
            var l = (!e || !1 !== e.end) && t !== r.stdout && t !== r.stderr ? c : k;

            function h(e, r) {
                p("onunpipe"), e === i && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, p("cleanup"), t.removeListener("close", m), t.removeListener("finish", y), t.removeListener("drain", u), t.removeListener("error", v), t.removeListener("unpipe", h), i.removeListener("end", c), i.removeListener("end", k), i.removeListener("data", g), d = !0, !s.awaitDrain || t._writableState && !t._writableState.needDrain || u())
            }

            function c() {
                p("onend"), t.end()
            }

            s.endEmitted ? n.nextTick(l) : i.once("end", l), t.on("unpipe", h);
            var u = function (t) {
                return function () {
                    var e = t._readableState;
                    p("pipeOnDrain", e.awaitDrain), e.awaitDrain && e.awaitDrain--, 0 === e.awaitDrain && o(t, "data") && (e.flowing = !0, P(t))
                }
            }(i);
            t.on("drain", u);
            var d = !1;
            var f = !1;

            function g(e) {
                p("ondata"), f = !1, !1 !== t.write(e) || f || ((1 === s.pipesCount && s.pipes === t || s.pipesCount > 1 && -1 !== _(s.pipes, t)) && !d && (p("false write response, pause", i._readableState.awaitDrain), i._readableState.awaitDrain++, f = !0), i.pause())
            }

            function v(e) {
                p("onerror", e), k(), t.removeListener("error", v), 0 === o(t, "error") && t.emit("error", e)
            }

            function m() {
                t.removeListener("finish", y), k()
            }

            function y() {
                p("onfinish"), t.removeListener("close", m), k()
            }

            function k() {
                p("unpipe"), i.unpipe(t)
            }

            return i.on("data", g), function (t, e, i) {
                if ("function" == typeof t.prependListener) return t.prependListener(e, i);
                t._events && t._events[e] ? a(t._events[e]) ? t._events[e].unshift(i) : t._events[e] = [i, t._events[e]] : t.on(e, i)
            }(t, "error", v), t.once("close", m), t.once("finish", y), t.emit("pipe", i), s.flowing || (p("pipe resume"), i.resume()), t
        }, k.prototype.unpipe = function (t) {
            var e = this._readableState, i = {hasUnpiped: !1};
            if (0 === e.pipesCount) return this;
            if (1 === e.pipesCount) return t && t !== e.pipes || (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, i)), this;
            if (!t) {
                var r = e.pipes, n = e.pipesCount;
                e.pipes = null, e.pipesCount = 0, e.flowing = !1;
                for (var s = 0; s < n; s++) r[s].emit("unpipe", this, i);
                return this
            }
            var a = _(e.pipes, t);
            return -1 === a || (e.pipes.splice(a, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, i)), this
        }, k.prototype.on = function (t, e) {
            var i = l.prototype.on.call(this, t, e);
            if ("data" === t) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === t) {
                var r = this._readableState;
                r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.emittedReadable = !1, r.reading ? r.length && b(this) : n.nextTick(I, this))
            }
            return i
        }, k.prototype.addListener = k.prototype.on, k.prototype.resume = function () {
            var t = this._readableState;
            return t.flowing || (p("resume"), t.flowing = !0, function (t, e) {
                e.resumeScheduled || (e.resumeScheduled = !0, n.nextTick(D, t, e))
            }(this, t)), this
        }, k.prototype.pause = function () {
            return p("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this
        }, k.prototype.wrap = function (t) {
            var e = this, i = this._readableState, r = !1;
            for (var n in t.on("end", (function () {
                if (p("wrapped end"), i.decoder && !i.ended) {
                    var t = i.decoder.end();
                    t && t.length && e.push(t)
                }
                e.push(null)
            })), t.on("data", (function (n) {
                (p("wrapped data"), i.decoder && (n = i.decoder.write(n)), i.objectMode && null == n) || (i.objectMode || n && n.length) && (e.push(n) || (r = !0, t.pause()))
            })), t) void 0 === this[n] && "function" == typeof t[n] && (this[n] = function (e) {
                return function () {
                    return t[e].apply(t, arguments)
                }
            }(n));
            for (var s = 0; s < m.length; s++) t.on(m[s], this.emit.bind(this, m[s]));
            return this._read = function (e) {
                p("wrapped _read", e), r && (r = !1, t.resume())
            }, this
        }, Object.defineProperty(k.prototype, "readableHighWaterMark", {
            enumerable: !1, get: function () {
                return this._readableState.highWaterMark
            }
        }), k._fromList = R
    }).call(this, i(2), i(4))
}, function (t, e, i) {
    t.exports = i(9).EventEmitter
}, function (t, e, i) {
    "use strict";
    var r = i(7);

    function n(t, e) {
        t.emit("error", e)
    }

    t.exports = {
        destroy: function (t, e) {
            var i = this, s = this._readableState && this._readableState.destroyed,
                a = this._writableState && this._writableState.destroyed;
            return s || a ? (e ? e(t) : !t || this._writableState && this._writableState.errorEmitted || r.nextTick(n, this, t), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function (t) {
                !e && t ? (r.nextTick(n, i, t), i._writableState && (i._writableState.errorEmitted = !0)) : e && e(t)
            })), this)
        }, undestroy: function () {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
        }
    }
}, function (t, e, i) {
    "use strict";
    t.exports = a;
    var r = i(1), n = Object.create(i(5));

    function s(t, e) {
        var i = this._transformState;
        i.transforming = !1;
        var r = i.writecb;
        if (!r) return this.emit("error", new Error("write callback called multiple times"));
        i.writechunk = null, i.writecb = null, null != e && this.push(e), r(t);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark)
    }

    function a(t) {
        if (!(this instanceof a)) return new a(t);
        r.call(this, t), this._transformState = {
            afterTransform: s.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", o)
    }

    function o() {
        var t = this;
        "function" == typeof this._flush ? this._flush((function (e, i) {
            l(t, e, i)
        })) : l(this, null, null)
    }

    function l(t, e, i) {
        if (e) return t.emit("error", e);
        if (null != i && t.push(i), t._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (t._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return t.push(null)
    }

    n.inherits = i(3), n.inherits(a, r), a.prototype.push = function (t, e) {
        return this._transformState.needTransform = !1, r.prototype.push.call(this, t, e)
    }, a.prototype._transform = function (t, e, i) {
        throw new Error("_transform() is not implemented")
    }, a.prototype._write = function (t, e, i) {
        var r = this._transformState;
        if (r.writecb = i, r.writechunk = t, r.writeencoding = e, !r.transforming) {
            var n = this._readableState;
            (r.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark)
        }
    }, a.prototype._read = function (t) {
        var e = this._transformState;
        null !== e.writechunk && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0
    }, a.prototype._destroy = function (t, e) {
        var i = this;
        r.prototype._destroy.call(this, t, (function (t) {
            e(t), i.emit("close")
        }))
    }
}, function (t) {
    t.exports = JSON.parse('{"name":"@yospace/admanagement-sdk","version":"3.4.0","description":"Yospace AdManagement SDK","homepage":"https://yospace.com","main":"lib/index.js","types":"types/index.d.ts","private":false,"publishConfig":{"registry":"https://yospacerepo.jfrog.io/artifactory/api/npm/javascript-sdk-release/"},"dependencies":{"sax":"^1.2.4"},"devDependencies":{"@babel/core":"^7.15.0","babel-loader":"^8.2.2","babel-plugin-transform-es2015-modules-simple-commonjs":"^0.3.0","@babel/preset-env":"^7.15.6","better-docs":"^2.3.2","docdash":"^1.2.0","jest":"^27.0.6","jest-junit":"^13.0.0","jest-sonar-reporter":"^2.0.0","jsdoc":"^3.6.7","jsdoc-fresh":"^1.1.0","jsdoc-mermaid":"^1.0.0","jshint":"^2.13.0","node-fetch":"^2.6.1","nodemon":"^2.0.12","nwb":"^0.25.2","typescript":"^4.4.2","webpack":"^4.0.0","webpack-cli":"^4.7.2"},"scripts":{"build":"webpack","build-es5":"webpack --config webpack.config-es5.js","build:npm":"nwb build --no-demo","doc":"jsdoc -c jsdoc.json --readme src/README.md -d docs","lint":"jshint --config .jshintrc ./src/ || true","test":"jest --runInBand --coverage --forceExit --bail","testUnit":"jest --runInBand --coverage --forceExit -t UNIT","testIntegration":"jest --runInBand --coverage --forceExit --bail -t INTEGRATION","tsdefs":"npx -p typescript tsc src/index.js --stripInternal --declaration --allowJs --emitDeclarationOnly --outDir types","tsdefsHosting":"npx -p typescript tsc src/index.js --stripInternal --declaration --allowJs --emitDeclarationOnly --outDir types-${npm_package_version}"},"author":{"name":"Yospace Technologies Ltd","email":"sdk-team@yospace.com"},"license":"SEE LICENSE IN LICENCE","files":["lib/","docs/","types/"]}')
}, function (t, e, i) {
    "use strict";
    e.byteLength = function (t) {
        var e = h(t), i = e[0], r = e[1];
        return 3 * (i + r) / 4 - r
    }, e.toByteArray = function (t) {
        var e, i, r = h(t), a = r[0], o = r[1], l = new s(function (t, e, i) {
            return 3 * (e + i) / 4 - i
        }(0, a, o)), c = 0, u = o > 0 ? a - 4 : a;
        for (i = 0; i < u; i += 4) e = n[t.charCodeAt(i)] << 18 | n[t.charCodeAt(i + 1)] << 12 | n[t.charCodeAt(i + 2)] << 6 | n[t.charCodeAt(i + 3)], l[c++] = e >> 16 & 255, l[c++] = e >> 8 & 255, l[c++] = 255 & e;
        2 === o && (e = n[t.charCodeAt(i)] << 2 | n[t.charCodeAt(i + 1)] >> 4, l[c++] = 255 & e);
        1 === o && (e = n[t.charCodeAt(i)] << 10 | n[t.charCodeAt(i + 1)] << 4 | n[t.charCodeAt(i + 2)] >> 2, l[c++] = e >> 8 & 255, l[c++] = 255 & e);
        return l
    }, e.fromByteArray = function (t) {
        for (var e, i = t.length, n = i % 3, s = [], a = 0, o = i - n; a < o; a += 16383) s.push(c(t, a, a + 16383 > o ? o : a + 16383));
        1 === n ? (e = t[i - 1], s.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === n && (e = (t[i - 2] << 8) + t[i - 1], s.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "="));
        return s.join("")
    };
    for (var r = [], n = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, l = a.length; o < l; ++o) r[o] = a[o], n[a.charCodeAt(o)] = o;

    function h(t) {
        var e = t.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var i = t.indexOf("=");
        return -1 === i && (i = e), [i, i === e ? 0 : 4 - i % 4]
    }

    function c(t, e, i) {
        for (var n, s, a = [], o = e; o < i; o += 3) n = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), a.push(r[(s = n) >> 18 & 63] + r[s >> 12 & 63] + r[s >> 6 & 63] + r[63 & s]);
        return a.join("")
    }

    n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63
}, function (t, e) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    e.read = function (t, e, i, r, n) {
        var s, a, o = 8 * n - r - 1, l = (1 << o) - 1, h = l >> 1, c = -7, u = i ? n - 1 : 0, d = i ? -1 : 1,
            p = t[e + u];
        for (u += d, s = p & (1 << -c) - 1, p >>= -c, c += o; c > 0; s = 256 * s + t[e + u], u += d, c -= 8) ;
        for (a = s & (1 << -c) - 1, s >>= -c, c += r; c > 0; a = 256 * a + t[e + u], u += d, c -= 8) ;
        if (0 === s) s = 1 - h; else {
            if (s === l) return a ? NaN : 1 / 0 * (p ? -1 : 1);
            a += Math.pow(2, r), s -= h
        }
        return (p ? -1 : 1) * a * Math.pow(2, s - r)
    }, e.write = function (t, e, i, r, n, s) {
        var a, o, l, h = 8 * s - n - 1, c = (1 << h) - 1, u = c >> 1,
            d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : s - 1, f = r ? 1 : -1,
            g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (a++, l /= 2), a + u >= c ? (o = 0, a = c) : a + u >= 1 ? (o = (e * l - 1) * Math.pow(2, n), a += u) : (o = e * Math.pow(2, u - 1) * Math.pow(2, n), a = 0)); n >= 8; t[i + p] = 255 & o, p += f, o /= 256, n -= 8) ;
        for (a = a << n | o, h += n; h > 0; t[i + p] = 255 & a, p += f, a /= 256, h -= 8) ;
        t[i + p - f] |= 128 * g
    }
}, function (t, e) {
    var i = {}.toString;
    t.exports = Array.isArray || function (t) {
        return "[object Array]" == i.call(t)
    }
}, function (t, e, i) {
    t.exports = n;
    var r = i(9).EventEmitter;

    function n() {
        r.call(this)
    }

    i(3)(n, r), n.Readable = i(10), n.Writable = i(32), n.Duplex = i(33), n.Transform = i(34), n.PassThrough = i(35), n.Stream = n, n.prototype.pipe = function (t, e) {
        var i = this;

        function n(e) {
            t.writable && !1 === t.write(e) && i.pause && i.pause()
        }

        function s() {
            i.readable && i.resume && i.resume()
        }

        i.on("data", n), t.on("drain", s), t._isStdio || e && !1 === e.end || (i.on("end", o), i.on("close", l));
        var a = !1;

        function o() {
            a || (a = !0, t.end())
        }

        function l() {
            a || (a = !0, "function" == typeof t.destroy && t.destroy())
        }

        function h(t) {
            if (c(), 0 === r.listenerCount(this, "error")) throw t
        }

        function c() {
            i.removeListener("data", n), t.removeListener("drain", s), i.removeListener("end", o), i.removeListener("close", l), i.removeListener("error", h), t.removeListener("error", h), i.removeListener("end", c), i.removeListener("close", c), t.removeListener("close", c)
        }

        return i.on("error", h), t.on("error", h), i.on("end", c), i.on("close", c), t.on("close", c), t.emit("pipe", i), t
    }
}, function (t, e) {
    var i = {}.toString;
    t.exports = Array.isArray || function (t) {
        return "[object Array]" == i.call(t)
    }
}, function (t, e) {
}, function (t, e, i) {
    "use strict";
    var r = i(11).Buffer, n = i(26);
    t.exports = function () {
        function t() {
            !function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.head = null, this.tail = null, this.length = 0
        }

        return t.prototype.push = function (t) {
            var e = {data: t, next: null};
            this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length
        }, t.prototype.unshift = function (t) {
            var e = {data: t, next: this.head};
            0 === this.length && (this.tail = e), this.head = e, ++this.length
        }, t.prototype.shift = function () {
            if (0 !== this.length) {
                var t = this.head.data;
                return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t
            }
        }, t.prototype.clear = function () {
            this.head = this.tail = null, this.length = 0
        }, t.prototype.join = function (t) {
            if (0 === this.length) return "";
            for (var e = this.head, i = "" + e.data; e = e.next;) i += t + e.data;
            return i
        }, t.prototype.concat = function (t) {
            if (0 === this.length) return r.alloc(0);
            if (1 === this.length) return this.head.data;
            for (var e, i, n, s = r.allocUnsafe(t >>> 0), a = this.head, o = 0; a;) e = a.data, i = s, n = o, e.copy(i, n), o += a.data.length, a = a.next;
            return s
        }, t
    }(), n && n.inspect && n.inspect.custom && (t.exports.prototype[n.inspect.custom] = function () {
        var t = n.inspect({length: this.length});
        return this.constructor.name + " " + t
    })
}, function (t, e) {
}, function (t, e, i) {
    (function (t) {
        var r = void 0 !== t && t || "undefined" != typeof self && self || window, n = Function.prototype.apply;

        function s(t, e) {
            this._id = t, this._clearFn = e
        }

        e.setTimeout = function () {
            return new s(n.call(setTimeout, r, arguments), clearTimeout)
        }, e.setInterval = function () {
            return new s(n.call(setInterval, r, arguments), clearInterval)
        }, e.clearTimeout = e.clearInterval = function (t) {
            t && t.close()
        }, s.prototype.unref = s.prototype.ref = function () {
        }, s.prototype.close = function () {
            this._clearFn.call(r, this._id)
        }, e.enroll = function (t, e) {
            clearTimeout(t._idleTimeoutId), t._idleTimeout = e
        }, e.unenroll = function (t) {
            clearTimeout(t._idleTimeoutId), t._idleTimeout = -1
        }, e._unrefActive = e.active = function (t) {
            clearTimeout(t._idleTimeoutId);
            var e = t._idleTimeout;
            e >= 0 && (t._idleTimeoutId = setTimeout((function () {
                t._onTimeout && t._onTimeout()
            }), e))
        }, i(28), e.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, e.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate
    }).call(this, i(2))
}, function (t, e, i) {
    (function (t, e) {
        !function (t, i) {
            "use strict";
            if (!t.setImmediate) {
                var r, n, s, a, o, l = 1, h = {}, c = !1, u = t.document,
                    d = Object.getPrototypeOf && Object.getPrototypeOf(t);
                d = d && d.setTimeout ? d : t, "[object process]" === {}.toString.call(t.process) ? r = function (t) {
                    e.nextTick((function () {
                        f(t)
                    }))
                } : !function () {
                    if (t.postMessage && !t.importScripts) {
                        var e = !0, i = t.onmessage;
                        return t.onmessage = function () {
                            e = !1
                        }, t.postMessage("", "*"), t.onmessage = i, e
                    }
                }() ? t.MessageChannel ? ((s = new MessageChannel).port1.onmessage = function (t) {
                    f(t.data)
                }, r = function (t) {
                    s.port2.postMessage(t)
                }) : u && "onreadystatechange" in u.createElement("script") ? (n = u.documentElement, r = function (t) {
                    var e = u.createElement("script");
                    e.onreadystatechange = function () {
                        f(t), e.onreadystatechange = null, n.removeChild(e), e = null
                    }, n.appendChild(e)
                }) : r = function (t) {
                    setTimeout(f, 0, t)
                } : (a = "setImmediate$" + Math.random() + "$", o = function (e) {
                    e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(a) && f(+e.data.slice(a.length))
                }, t.addEventListener ? t.addEventListener("message", o, !1) : t.attachEvent("onmessage", o), r = function (e) {
                    t.postMessage(a + e, "*")
                }), d.setImmediate = function (t) {
                    "function" != typeof t && (t = new Function("" + t));
                    for (var e = new Array(arguments.length - 1), i = 0; i < e.length; i++) e[i] = arguments[i + 1];
                    var n = {callback: t, args: e};
                    return h[l] = n, r(l), l++
                }, d.clearImmediate = p
            }

            function p(t) {
                delete h[t]
            }

            function f(t) {
                if (c) setTimeout(f, 0, t); else {
                    var e = h[t];
                    if (e) {
                        c = !0;
                        try {
                            !function (t) {
                                var e = t.callback, i = t.args;
                                switch (i.length) {
                                    case 0:
                                        e();
                                        break;
                                    case 1:
                                        e(i[0]);
                                        break;
                                    case 2:
                                        e(i[0], i[1]);
                                        break;
                                    case 3:
                                        e(i[0], i[1], i[2]);
                                        break;
                                    default:
                                        e.apply(void 0, i)
                                }
                            }(e)
                        } finally {
                            p(t), c = !1
                        }
                    }
                }
            }
        }("undefined" == typeof self ? void 0 === t ? this : t : self)
    }).call(this, i(2), i(4))
}, function (t, e, i) {
    (function (e) {
        function i(t) {
            try {
                if (!e.localStorage) return !1
            } catch (t) {
                return !1
            }
            var i = e.localStorage[t];
            return null != i && "true" === String(i).toLowerCase()
        }

        t.exports = function (t, e) {
            if (i("noDeprecation")) return t;
            var r = !1;
            return function () {
                if (!r) {
                    if (i("throwDeprecation")) throw new Error(e);
                    i("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0
                }
                return t.apply(this, arguments)
            }
        }
    }).call(this, i(2))
}, function (t, e, i) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var r = i(6), n = r.Buffer;

    function s(t, e) {
        for (var i in t) e[i] = t[i]
    }

    function a(t, e, i) {
        return n(t, e, i)
    }

    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (s(r, e), e.Buffer = a), a.prototype = Object.create(n.prototype), s(n, a), a.from = function (t, e, i) {
        if ("number" == typeof t) throw new TypeError("Argument must not be a number");
        return n(t, e, i)
    }, a.alloc = function (t, e, i) {
        if ("number" != typeof t) throw new TypeError("Argument must be a number");
        var r = n(t);
        return void 0 !== e ? "string" == typeof i ? r.fill(e, i) : r.fill(e) : r.fill(0), r
    }, a.allocUnsafe = function (t) {
        if ("number" != typeof t) throw new TypeError("Argument must be a number");
        return n(t)
    }, a.allocUnsafeSlow = function (t) {
        if ("number" != typeof t) throw new TypeError("Argument must be a number");
        return r.SlowBuffer(t)
    }
}, function (t, e, i) {
    "use strict";
    t.exports = s;
    var r = i(17), n = Object.create(i(5));

    function s(t) {
        if (!(this instanceof s)) return new s(t);
        r.call(this, t)
    }

    n.inherits = i(3), n.inherits(s, r), s.prototype._transform = function (t, e, i) {
        i(null, t)
    }
}, function (t, e, i) {
    t.exports = i(12)
}, function (t, e, i) {
    t.exports = i(1)
}, function (t, e, i) {
    t.exports = i(10).Transform
}, function (t, e, i) {
    t.exports = i(10).PassThrough
}, function (t, e, i) {
    "use strict";
    i.r(e), i.d(e, "DEBUG_ALL", (function () {
        return d
    })), i.d(e, "DEBUG_PLAYBACK", (function () {
        return n
    })), i.d(e, "DEBUG_HTTP_REQUESTS", (function () {
        return h
    })), i.d(e, "DEBUG_LIFECYCLE", (function () {
        return s
    })), i.d(e, "DEBUG_PARSING", (function () {
        return c
    })), i.d(e, "DEBUG_POLLING", (function () {
        return a
    })), i.d(e, "DEBUG_REPORTS", (function () {
        return o
    })), i.d(e, "DEBUG_STATE_MACHINE", (function () {
        return l
    })), i.d(e, "DEBUG_VALIDATION", (function () {
        return u
    })), i.d(e, "CAT_AD_BREAK_EVENTS", (function () {
        return r.b
    })), i.d(e, "CAT_TIMELINE_EVENTS", (function () {
        return r.c
    })), i.d(e, "CONNECTION_ERROR", (function () {
        return ct
    })), i.d(e, "CONNECTION_TIMEOUT", (function () {
        return ut
    })), i.d(e, "MALFORMED_URL", (function () {
        return dt
    })), i.d(e, "UNKNOWN_FORMAT", (function () {
        return pt
    })), i.d(e, "AdBreak", (function () {
        return J
    })), i.d(e, "AdVerification", (function () {
        return j
    })), i.d(e, "Advert", (function () {
        return Q
    })), i.d(e, "AdvertEventHandler", (function () {
        return F
    })), i.d(e, "AdvertWrapper", (function () {
        return q
    })), i.d(e, "AnalyticBroker", (function () {
        return rt
    })), i.d(e, "AnalyticEventObserver", (function () {
        return nt
    })), i.d(e, "BreakType", (function () {
        return $
    })), i.d(e, "CompanionAds", (function () {
        return b
    })), i.d(e, "Creative", (function () {
        return C
    })), i.d(e, "CreativeEventHandler", (function () {
        return w
    })), i.d(e, "IconClickFallbackImage", (function () {
        return W
    })), i.d(e, "IndustryIcon", (function () {
        return Y
    })), i.d(e, "InteractiveCreative", (function () {
        return X
    })), i.d(e, "LinearCreative", (function () {
        return K
    })), i.d(e, "NonLinearCreative", (function () {
        return G
    })), i.d(e, "PlaybackEventHandler", (function () {
        return it
    })), i.d(e, "PlaybackMode", (function () {
        return lt
    })), i.d(e, "PlaybackPolicy", (function () {
        return Z
    })), i.d(e, "PlaybackPolicyHandler", (function () {
        return vt
    })), i.d(e, "PlayerEvent", (function () {
        return tt
    })), i.d(e, "Resource", (function () {
        return E
    })), i.d(e, "ResourceType", (function () {
        return A
    })), i.d(e, "Session", (function () {
        return ft
    })), i.d(e, "SessionDVRLive", (function () {
        return Yt
    })), i.d(e, "SessionLive", (function () {
        return Kt
    })), i.d(e, "SessionVOD", (function () {
        return $t
    })), i.d(e, "SessionProperties", (function () {
        return gt
    })), i.d(e, "SessionResult", (function () {
        return ht
    })), i.d(e, "TimedMetadata", (function () {
        return Gt
    })), i.d(e, "VASTProperty", (function () {
        return N
    })), i.d(e, "VerificationEventHandler", (function () {
        return H
    })), i.d(e, "ViewableEvent", (function () {
        return O
    })), i.d(e, "ViewSize", (function () {
        return et
    })), i.d(e, "YoLog", (function () {
        return p
    }));
    var r = i(0);
    const n = 1, s = 2, a = 4, o = 8, l = 16, h = 32, c = 64, u = 128, d = Number.MAX_SAFE_INTEGER;

    class p {
        static setLogger(t) {
            p.logger = t
        }

        static addDebugFlags(t) {
            p.debugflags |= t
        }

        static setDebugFlags(t) {
            p.debugflags = t
        }

        static getDebugFlags() {
            return p.debugflags
        }

        static d(t, e) {
            p.debugflags & t && p.logger.debug(Object(r.u)() + e)
        }

        static e(t) {
            p.logger.error(Object(r.u)() + t)
        }

        static i(t, e) {
            p.debugflags & t && p.logger.info(Object(r.u)() + e)
        }

        static w(t) {
            p.logger.warn(Object(r.u)() + t)
        }

        static trace(t) {
            p.d(u, "[" + Date.now() + "][YoSDK:" + t + "]")
        }
    }

    p.debugflags = 0, p.logger = class {
        static debug(t) {
            console.log(t)
        }

        static error(t) {
            console.error(t)
        }

        static info(t) {
            console.info(t)
        }

        static warn(t) {
            console.warn(t)
        }
    };

    class f {
        constructor() {
            if (new.target === f) throw new TypeError("Cannot construct abstract class XmlValidation directly")
        }

        isValid() {
            return !0
        }
    }

    class g extends f {
        onNonLinearTrackingEvent(t) {
            throw new Error("Function must be overridden")
        }
    }

    function v(t, e) {
        return null === t ? null === e : void 0 === t ? void 0 === e : !(!m(t) || !m(e)) && t.toUpperCase() === e.toUpperCase()
    }

    function m(t) {
        return "string" == typeof t || t instanceof String
    }

    function y(t) {
        return t ? "    " + t.toString().replace("\n", "\n    ") : "null"
    }

    function k(t) {
        return !t || "" === t
    }

    function T(t, e, i) {
        let r = t;
        if (0 === e || ">" === e) {
            r += "\n";
            for (let t = 0; t < 4 * i; ++t) r += " "
        }
        return r
    }

    const A = {STATIC: 0, HTML: 1, IFRAME: 2, UNKNOWN: 3};

    class E extends f {
        constructor(t, e, i, r) {
            switch (super(), t) {
                case A.STATIC:
                    this.stringData = e, this.creativeType = i, this.resourceType = t, this.encoded = !1, this.type = t;
                    break;
                case A.IFRAME:
                    this.stringData = e, this.creativeType = null, this.type = t, this.encoded = !1;
                    break;
                case A.HTML:
                    this.stringData = e, this.creativeType = null, this.type = t, this.encoded = r
            }
            this.byteData = null
        }

        getByteData() {
            return this.byteData
        }

        getCreativeType() {
            return this.creativeType
        }

        getResourceType() {
            return this.type
        }

        getStringData() {
            return this.stringData
        }

        isEncoded() {
            return this.encoded
        }

        isValid() {
            switch (this.type) {
                case A.STATIC:
                    if (!this.creativeType || "" === this.creativeType) return !1;
                    break;
                case A.HTML:
                    if (!this.stringData || "" === this.stringData) return !1;
                    break;
                case A.IFRAME:
                    try {
                        new URL(this.stringData)
                    } catch (t) {
                        return !1
                    }
                    break;
                default:
                    return !1
            }
            return !0
        }

        prefetch() {
            this.byteData || this.type === A.HTML || this.type === A.UNKNOWN || fetch(this.stringData, {method: "GET"}).then(t => {
                t.ok ? t.text().then(t => {
                    this.byteData = t
                }) : p.e("Resource prefetch failed.  URL: " + this.stringData + ", status: " + t.status + ", error:" + t.statusText)
            }).catch(t => {
                p.e("Primary Url request failed: " + this.stringData + ", status: " + t.status + ", error:" + t.statusText)
            })
        }

        toString() {
            let t = "";
            switch (this.type) {
                case A.STATIC:
                    t += "\nStatic resource (", t += this.creativeType, t += "): ", t += this.stringData;
                    break;
                case A.HTML:
                    t += "\nHTML resource (", t += this.encoded ? "encoded): " : "unencoded): ", t += function (t) {
                        if (!t) return "";
                        try {
                            let e = 0, i = "", r = null, n = 0;
                            for (let s = 0; s < t.length; ++s) {
                                if (r = t[s], "<" === r) {
                                    let r = t[s + 1];
                                    "/" === r && e--, i = T(i, n, e), "/" !== r && "!" !== r && e++
                                }
                                i += r, n = r
                            }
                            if (0 === e) return i
                        } catch (t) {
                        }
                        return t
                    }(this.stringData);
                    break;
                case A.IFRAME:
                    t += "\niFrame resource: ", t += this.stringData
            }
            return t
        }
    }

    class b {
        constructor(t, e) {
            this.required = t, this.companions = e || []
        }

        containsCreative(t) {
            return -1 !== this.companions.indexOf(t)
        }

        getCompanions() {
            return Object.assign([], this.companions)
        }

        getCompanionsByType(t) {
            let e = [];
            for (let i of this.companions) (i.getResource(t) || t === A.UNKNOWN && 0 === i.getResources().size) && e.push(i);
            return e
        }

        getRequired() {
            return this.required
        }

        prefetchResources() {
            for (let t of this.companions) t.prefetchResources()
        }

        toString() {
            let t = "";
            if (this.companions.length > 0) {
                t = "\n--- Companion Ads required:", t += this.required;
                for (let e of this.companions) t += y(e)
            }
            return t
        }
    }

    class w extends f {
        onClickThrough() {
            throw new Error("Function must be overridden")
        }

        onTrackingEvent(t) {
            throw new Error("Function must be overridden")
        }

        setVisible(t) {
            throw new Error("Function must be overridden")
        }
    }

    class S {
        constructor(t, e) {
            this.name = t, this.attributes = e || new Map, this.text = "", this.children = []
        }

        static attributeToString(t, e) {
            return " " + t + '="' + e + '"'
        }

        getAttributes() {
            return this.attributes
        }

        getAttribute(t) {
            return this.attributes.get(t)
        }

        getChildren() {
            return this.children
        }

        getInnerText() {
            return this.text
        }

        getName() {
            return this.name
        }

        addChild(t) {
            this.children.push(t)
        }

        setInnerText(t) {
            this.text = t
        }

        toString() {
            let t = "<";
            t += this.name;
            for (let [e, i] of this.attributes) t += S.attributeToString(e, i);
            if (0 === this.children.length && k(this.text)) t += "/>"; else {
                t += ">", k(this.text) || (t += this.text);
                for (let e of this.children) t += y("\n" + e);
                k(this.text) || 0 !== this.children.length ? t += (e = "\n</" + this.name + ">") ? "" + e.toString().replace("\n    ", "\n") : "null" : (t += "</", t += this.name, t += ">")
            }
            var e;
            return t
        }
    }

    class C extends w {
        constructor(t) {
            super(), this.advertId = t.advertId ? t.advertId : "", this.creativeId = t.id ? t.id : "", this.universalAdIds = t.universalAdIds, this.sequence = t.sequence, this.adParameters = t.adParameters, this.extensions = t.extensions, this.nonLinear = !1
        }

        getAdvertIdentifier() {
            return this.advertId
        }

        getAdParameters() {
            return this.adParameters
        }

        getExtensions() {
            return this.extensions
        }

        getCreativeIdentifier() {
            return this.creativeId
        }

        getSequence() {
            return this.sequence
        }

        getUniversalAdIds() {
            return this.universalAdIds
        }

        isNonLinear() {
            return this.nonLinear
        }

        setNonLinear(t) {
            this.nonLinear = t
        }

        setVisible(t) {
        }

        toString() {
            let t = "";
            if (t += `\n - Id:${this.creativeId} AdId:${this.advertId} Sequence:${this.sequence}`, this.adParameters && (t += "\n - AdParameters:", t += "\n" + y(this.adParameters)), this.universalAdIds) {
                t += "\n - UniversalAdIds:";
                for (let e of this.universalAdIds) t += "\n" + y(e)
            }
            return this.extensions && (t += "\n - CreativeExtensions:", t += "\n" + y(this.extensions)), t
        }
    }

    class I {
        constructor(t, e, i) {
            this.clickThroughUrl = t || "", this.clickTrackingUrls = e || [], this.customClicks = i || []
        }

        getClickThroughUrl() {
            return this.clickThroughUrl
        }

        getClickTrackingUrls() {
            return this.clickTrackingUrls
        }

        getCustomClicks() {
            return this.customClicks
        }

        toString() {
            let t = "";
            if (k(this.clickThroughUrl) || (t += "\n* Click-through Url: ", t += this.clickThroughUrl), this.clickTrackingUrls.length > 0) for (let e of this.clickTrackingUrls) t += "\n* Click tracking Url: ", t += e;
            if (this.customClicks.length > 0) for (let e of this.customClicks) t += "\n* Custom click Url: ", t += e;
            return t
        }
    }

    class D {
        static categoryForEvent(t) {
            return D.isValidAdBreakEvent(t) ? r.b : D.isTimelineEvent(t) ? r.c : 0
        }

        static isValidPlayerOperationEvent(t) {
            return -1 !== r.q.indexOf(t)
        }

        static isValidCompanionEvent(t) {
            return -1 !== r.d.indexOf(t)
        }

        static isValidInteractiveEvent(t) {
            return -1 !== r.f.indexOf(t)
        }

        static isValidLinearEvent(t) {
            return -1 !== r.g.indexOf(t)
        }

        static isValidNonLinearEvent(t) {
            return -1 !== r.h.indexOf(t)
        }

        static isValidVerificationEvent(t) {
            return -1 !== r.s.indexOf(t)
        }

        static isTimelineEvent(t) {
            return -1 !== r.r.indexOf(t)
        }

        static isValidAdBreakEvent(t) {
            return -1 !== r.a.indexOf(t)
        }

        static isValidVisibleEvent(t) {
            return -1 !== r.t.indexOf(t)
        }

        constructor(t, e) {
            this.trackingEvent = t, this.trackingUrls = JSON.parse(JSON.stringify(e || []))
        }

        addTrackingUrl(t) {
            t ? this.trackingUrls.push(t) : p.e("addTrackingUrl: url was null")
        }

        getEventType() {
            return this.trackingEvent
        }

        getTrackingUrls() {
            return Object.assign([], this.trackingUrls)
        }

        removeTrackingUrls() {
            this.trackingUrls = []
        }

        toString() {
            let t = "";
            t += "Event:", t += this.trackingEvent;
            for (let e of this.trackingUrls) t += "\n - Url:", t += e;
            return t
        }
    }

    function P(t, e) {
        return t.length > 0 ? new D(e, t) : null
    }

    function R(t) {
        if (!t) return !1;
        let e = null, i = null;
        for (let r of t) {
            let t = r.getName(), n = r.getValue();
            "width" !== t || k(n) ? "height" !== t || k(n) || (i = r) : e = r
        }
        return !(!e || !i)
    }

    function L(t) {
        for (let [, e] of t) e.prefetch()
    }

    class N {
        constructor(t, e, i, r) {
            this.name = t, this.value = e || "", this.attributes = new Map, i && r && this.addAttribute(i, r)
        }

        addAttribute(t, e) {
            this.attributes.set(t, e)
        }

        getName() {
            return this.name
        }

        getValue() {
            return this.value
        }

        getAttributes() {
            return this.attributes
        }

        setValue(t) {
            this.value = t
        }

        toString() {
            let t = "";
            if (t += "Property Name: ", t += this.name, k(this.value) || (t += ", Value: ", t += this.value), this.attributes.size > 0) {
                t += ", Attributes:{";
                for (let [e, i] of this.attributes) t += e + ":" + i + " ";
                t += "}"
            }
            return t
        }
    }

    class _ extends C {
        constructor(t, e, i, r, n) {
            super(t), this.resources = new Map, this.visible = !1, this.properties = t.properties ? t.properties : [], this.altText = t.altText, this.trackingMap = r || new Map, this.videoClicks = e || new I, this.broker = n;
            for (let t of i) this.resources.set(t.getResourceType(), t);
            if (t.companionExtensions) for (let e of t.companionExtensions.getChildren()) this.extensions.addChild(e)
        }

        getAltText() {
            return this.altText
        }

        getClickThroughUrl() {
            return this.videoClicks.getClickThroughUrl()
        }

        getClickTrackingUrls() {
            return this.videoClicks.getClickTrackingUrls()
        }

        getProperties() {
            return Object.assign([], this.properties)
        }

        getProperty(t) {
            for (let e of this.properties) if (e.getName() === t) return e;
            return null
        }

        getResource(t) {
            return this.resources.has(t) ? this.resources.get(t) : null
        }

        getResources() {
            return this.resources
        }

        getTrackingMap() {
            return this.trackingMap
        }

        isValid() {
            return R(this.properties) && this.resources.size > 0 || this.trackingMap.size > 0
        }

        isVisible() {
            return this.visible
        }

        onClickThrough() {
            if (!this.isVisible()) return void p.w("Companion is not visible");
            let t = P(this.videoClicks.getClickTrackingUrls(), "CompanionClickTracking");
            t && this.broker.fireTrackingReportForCreative(t, this)
        }

        onTrackingEvent(t) {
        }

        prefetchResources() {
            L(this.resources)
        }

        setVisible(t) {
            if (this.visible !== t && (this.visible = t, t)) {
                let t = "creativeView", e = this.trackingMap.get(t);
                e && this.broker.fireTrackingReportForCreative(e, this)
            }
        }

        toString() {
            let t = "\n--- Companion ---\n";
            for (let e of this.properties) t += "\n" + y(e);
            t += y("\nAlt Text: " + this.altText), t += y(this.videoClicks);
            for (let [e, i] of this.resources) t += y(e + ":" + i);
            return t += super.toString(), t
        }
    }

    function M(t, e) {
        if (!t || 0 === t.length || -1 === t.indexOf("T")) return e;
        let i = t.substring(t.indexOf("T"), t.length - 1);
        -1 === i.indexOf("+") && -1 === i.indexOf("-") && Number.isInteger(Number.parseInt(t.charAt(t.length - 1))) && (t += "Z");
        let r = Date.parse(t);
        return Number.isNaN(r) ? e : r
    }

    function B(t, e) {
        let i = void 0 !== e ? e : 0;
        if (!("string" == typeof t && t.length > 0)) return i;
        let r = t.split(":");
        if (3 !== r.length) return i;
        let n = parseInt(r[0]), s = parseInt(r[1]);
        if (Number.isNaN(n) || Number.isNaN(s)) return i;
        let a = 0, o = 0, l = r[2].split(".");
        return 2 !== l.length ? a = parseInt(r[2]) : (a = parseInt(l[0]), o = parseInt(l[1])), Number.isNaN(a) || Number.isNaN(o) || n > 23 || s > 59 || a > 59 ? i : 36e5 * n + 6e4 * s + 1e3 * a + o
    }

    function U(t) {
        let e = Math.floor(t / 1e3 % 60), i = Math.floor(t / 6e4 % 60), r = Math.floor(t / 36e5 % 24);
        return `${r < 10 ? 0 : ""}${r}:${i < 10 ? 0 : ""}${i}:${e < 10 ? 0 : ""}${e}.${(t = Math.round(t % 1e3)) < 10 ? "00" : t < 100 ? "0" : ""}${t}`
    }

    class x {
        constructor(t, e) {
            this.trackingMap = t || new Map, this.nonLinearCreatives = e || []
        }

        allNonLinearsAreInactive() {
            for (let t of this.nonLinearCreatives) if (t.isVisible()) return !1;
            return !0
        }

        containsCreative(t) {
            return -1 !== this.nonLinearCreatives.indexOf(t)
        }

        getNonLinearCreatives() {
            return Object.assign([], this.nonLinearCreatives)
        }

        getNonLinearCreativesByType(t) {
            let e = [];
            for (let i of this.nonLinearCreatives) i.getResource(t) && e.push(i);
            return e
        }

        getTrackingMap() {
            return this.trackingMap
        }

        getTrackingReport(t) {
            if (!this.allNonLinearsAreInactive()) return this.trackingMap.get(t)
        }

        postParse() {
            for (let t of this.nonLinearCreatives) t.setTrackingReports(this.trackingMap)
        }

        prefetchResources() {
            for (let t of this.nonLinearCreatives) t.prefetchResources()
        }

        toString() {
            if (this.nonLinearCreatives.length > 0) {
                let t = "\n--- NonLinear Ads:";
                if (this.trackingMap.size > 0) {
                    t += "\n  ** Tracking events - ";
                    for (let [e, i] of this.trackingMap) t += y("\n " + e + ":" + i)
                }
                for (let e of this.nonLinearCreatives) t += y(e);
                return t
            }
            return ""
        }
    }

    const O = Object.freeze({VIEWABLE: 0, NOT_VIEWABLE: 1, VIEW_UNDETERMINED: 2});

    class F extends f {
        onViewableEvent(t) {
            throw new Error("Function must be overridden")
        }

        onErrorEvent(t) {
            throw new Error("Function must be overridden")
        }

        onImpressionEvent() {
            throw new Error("Function must be overridden")
        }
    }

    class V {
        constructor(t, e) {
            this.payload = t, this.source = e || null
        }

        getPayload() {
            return this.payload
        }

        getSource() {
            return this.source
        }
    }

    class H extends f {
        onVerificationEvent(t, e) {
            throw new Error("Function must be overridden")
        }
    }

    class j extends H {
        constructor(t) {
            super(), this.vendor = t.verificationVendor, this.resources = t.verificationResources, this.verificationEvents = t.verificationEvents, this.parameters = t.verificationParameters, this.listeners = [], this.broker = null
        }

        getAdVerificationEvents() {
            return this.verificationEvents
        }

        getParameters() {
            return this.parameters
        }

        getResources() {
            return Object.assign([], this.resources)
        }

        getVendor() {
            return this.vendor
        }

        isValid() {
            return !!(this.vendor && this.resources && this.resources.length > 0)
        }

        onVerificationEvent(t, e) {
            if (0 === this.listeners.length) return void p.w("No event listeners - can't signal VerificationEvent");
            let i = this.verificationEvents.get(t);
            if (i) {
                for (let t of this.listeners) t(new V(e));
                this.broker.fireTrackingReport(i)
            }
        }

        postParse(t, e) {
            this.broker = t, e ? this.listeners.push(e) : p.e("postParse: callback was null")
        }

        toString() {
            let t = "";
            if (this.verificationEvents.size > 0) {
                t += "\n - Verification events:";
                for (let [e, i] of this.verificationEvents) t += "\n " + e + "=" + i
            }
            let e = "\n--- Ad Verification:\n - Vendor:";
            e += this.vendor, e += "\n - Resources:";
            for (let t of this.resources) e += "\n" + y(t);
            return e += t, e += "\n - VerificationParameters:", e += this.parameters, e
        }
    }

    class q extends f {
        constructor(t, e, i) {
            super(), this.identifier = t, this.creativeIdentifier = e, this.adSystem = i, this.child = null
        }

        getAdSystem() {
            return this.adSystem
        }

        getCreativeIdentifier() {
            return this.creativeIdentifier
        }

        getIdentifier() {
            return this.identifier
        }

        getLineage() {
            return this.child
        }

        isValid() {
            let t = this;
            do {
                if (!t.identifier || "" === t.identifier) return !1;
                t = t.getLineage()
            } while (t);
            return !0
        }

        setChild(t) {
            this.child = t
        }
    }

    class W extends f {
        constructor(t, e, i) {
            super(), this.properties = t || [], this.altText = e, this.resource = i
        }

        getAltText() {
            return this.altText
        }

        getProperties() {
            return Object.assign([], this.properties)
        }

        getProperty(t) {
            for (let e of this.properties) if (e.getName() === t) return e;
            return null
        }

        getResource() {
            return this.resource
        }

        isValid() {
            return !(!R(this.properties) || k(this.altText) && !this.resource)
        }
    }

    class Y extends w {
        constructor(t, e, i, r, n) {
            super(), this.resources = new Map, this.visible = !1, this.properties = t || [], this.videoClicks = i || new I, this.clickFallbackImages = r || [], this.broker = n;
            for (let t of e) this.resources.set(t.getResourceType(), t)
        }

        getClickFallbackImages() {
            return Object.assign([], this.clickFallbackImages)
        }

        getClickThroughUrl() {
            return this.videoClicks.getClickThroughUrl()
        }

        getClickTrackingUrls() {
            return this.videoClicks.getClickTrackingUrls()
        }

        isVisible() {
            return this.visible
        }

        getViewTrackingUrls() {
            return this.videoClicks.getCustomClicks()
        }

        getProperties() {
            return Object.assign([], this.properties)
        }

        getProperty(t) {
            for (let e of this.properties) if (e.getName() === t) return e
        }

        getResource(t) {
            return this.resources.get(t)
        }

        getResources() {
            return this.resources
        }

        isValid() {
            let t = null, e = null, i = null, r = null, n = null;
            for (let s of this.properties) {
                k(s.getValue()) || ("program" === s.getName() && (t = s), "width" === s.getName() && (e = s), "height" === s.getName() && (i = s), "xPosition" === s.getName() && (r = s), "yPosition" === s.getName() && (n = s))
            }
            return null !== e && null !== i && null !== t && null !== r && null !== n && this.resources.size > 0
        }

        onClickThrough() {
            if (this.isVisible()) {
                let t = this.videoClicks.getClickTrackingUrls();
                if (t.length > 0) {
                    let e = P(t, "IconClickTracking");
                    e && this.broker.fireTrackingReportForIcon(e, this)
                }
            }
        }

        onTrackingEvent(t) {
        }

        setVisible(t) {
            if (this.visible !== t && (this.visible = t, this.visible && this.videoClicks.getCustomClicks().length > 0)) {
                let t = new D("IconViewTracking", this.videoClicks.getCustomClicks());
                t && this.broker.fireTrackingReportForIcon(t, this)
            }
        }

        toString() {
            let t = "";
            t += this.videoClicks.toString(), this.properties.length > 0 && (t += "\nIcon Properties: ");
            for (let e of this.properties) t += "\n" + y(e);
            this.resources.length > 0 && (t += "\nIcon Resource(s): ");
            for (let [e, i] of this.resources) t += y(e + ":" + i);
            this.clickFallbackImages.length > 0 && (t += "\nIcon Click Fallback Images: ");
            for (let e of this.clickFallbackImages) t += "\n" + y(e);
            return t
        }
    }

    class G extends C {
        constructor(t, e, i, r) {
            if (super(t), this.resources = new Map, this.visible = !1, this.videoClicks = e || new I("", null, null), this.properties = t.properties ? t.properties : [], this.broker = r, this.trackingMap = new Map, i) for (let t of i) this.resources.set(t.getResourceType(), t)
        }

        getApiFramework() {
            let t = this.getProperty("apiFramework");
            return t ? t.getValue() : null
        }

        getClickThroughUrl() {
            return this.videoClicks.getClickThroughUrl()
        }

        getClickTrackingUrls() {
            return this.videoClicks.getClickTrackingUrls()
        }

        getProperties() {
            return Object.assign([], this.properties)
        }

        getProperty(t) {
            for (let e of this.properties) if (e.getName() === t) return e;
            return null
        }

        getResource(t) {
            return this.resources.get(t)
        }

        getResources() {
            return this.resources
        }

        getTrackingReports() {
            return this.trackingMap
        }

        isValid() {
            return R(this.properties) && this.resources.size > 0
        }

        isVisible() {
            return this.visible
        }

        onClickThrough() {
            if (!this.visible) return void p.w("Nonlinear creative is not visible");
            let t = this.videoClicks.getClickTrackingUrls();
            if (t.length > 0) {
                let e = P(t, "NonLinearClickTracking");
                e && this.broker.fireTrackingReportForCreative(e, this)
            }
        }

        onTrackingEvent(t) {
            if (!this.visible) return void p.w("Nonlinear creative is not visible");
            if (D.isValidVisibleEvent(t)) return void p.w("Use method setVisible() to signal event: " + t);
            if (D.isValidPlayerOperationEvent(t) && !this.isNonLinear) return void p.w("Use PlaybackEventHandler functions to signal event: " + t);
            if (!D.isValidNonLinearEvent(t)) return void p.w("Invalid tracking event: " + t);
            let e = this.trackingMap.get(t);
            e && this.broker.fireTrackingReportForCreative(e, this), "acceptInvitation" === t && this.broker.raiseTrackingCallbackForCreative(t, this)
        }

        prefetchResources() {
            L(this.resources)
        }

        setTrackingReports(t) {
            this.trackingMap = t
        }

        setVisible(t) {
            if (this.visible !== t) {
                this.visible = t;
                let e = null;
                e = t ? this.trackingMap.get("creativeView") : this.trackingMap.get("close"), e && this.broker.fireTrackingReportForCreative(e, this)
            }
        }

        toString() {
            let t = "\n--- NonLinear Creative:";
            t += y(this.videoClicks), this.properties.length > 0 && (t += "\n - NonLinear Properties: ");
            for (let e of this.properties) t += "\n" + y(e);
            this.resources.size > 0 && (t += "\n - NonLinear Resource(s): ");
            for (let [e, i] of this.resources) t += y(e + ":" + i);
            return t += super.toString(), t
        }
    }

    function z(t) {
        if (k(t)) return null;
        let e = null;
        try {
            e = new URL(t)
        } catch (t) {
            return null
        }
        if (!e) return null;
        try {
            decodeURI(e.pathname)
        } catch (t) {
            return null
        }
        return e
    }

    class X extends w {
        constructor(t, e, i, r) {
            super(), this.source = t, this.properties = e || [], this.broker = i, this.adParameters = null, this.advertDuration = 0, this.tracking = null, this.offset = 0, this.visible = !1, this.nonLinearCreatives = [], this.isSIMID() && (this.tracking = r)
        }

        getAdParameters() {
            return this.adParameters
        }

        getAdvertDuration() {
            return this.advertDuration
        }

        getNonLinearCreatives() {
            return this.nonLinearCreatives
        }

        getProperties() {
            return Object.assign([], this.properties)
        }

        getProperty(t) {
            for (let e of this.properties) if (e.getName() === t) return e;
            return null
        }

        getSource() {
            return this.source
        }

        getTracking() {
            return this.tracking
        }

        initialise(t, e, i) {
            this.adParameters = t, this.advertDuration = e, this.nonLinearCreatives = [];
            let r = this.getProperty("apiFramework");
            if (r) {
                let t = r.getValue();
                for (let e of i) {
                    let i = e.getProperty("apiFramework");
                    i && i.getValue() === t && this.nonLinearCreatives.push(e)
                }
            }
        }

        isSIMID() {
            for (const t of this.properties) if ("apiFramework" === t.getName() && "SIMID" === t.getValue()) return !0;
            return !1
        }

        isValid() {
            return !k(this.source)
        }

        isVisible() {
            return this.visible
        }

        onClickThrough() {
        }

        onTrackingEvent(t) {
            this.isVisible() ? z(t) ? this.isSIMID() && this.broker.fireTrackingReport(new D("custom", [t])) : p.w("Invalid custom tracker URL") : p.w("Warning: InteractiveCreative is not visible")
        }

        setTracking(t) {
            this.tracking = t
        }

        setVisible(t) {
            this.visible !== t && (this.visible = t, this.visible && this.isSIMID() && this.tracking && this.broker.fireTrackingReport(this.tracking))
        }

        toString() {
            let t = "InteractiveCreative source: " + this.source;
            if (this.properties.length > 0) {
                t += "\nProperties:";
                for (let e of this.properties) t += y(e)
            }
            return this.tracking && (t += "\nTracking event:", t += y("\n " + this.tracking)), t
        }
    }

    class K extends C {
        constructor(t, e, i, r) {
            super(t), this.duration = B(t.duration), this.trackingMap = t.trackingMap ? t.trackingMap : new Map, this.videoClicks = e || new I("", null, null), this.icons = t.icons, this.assetUri = t.currentAssetUri ? t.currentAssetUri : "", this.interactiveCreative = i, this.skipOffset = t.skipOffset, this.broker = r
        }

        getAssetUri() {
            return this.assetUri
        }

        getClickThroughUrl() {
            return this.videoClicks.getClickThroughUrl()
        }

        getClickTrackingUrls() {
            return this.videoClicks.getClickTrackingUrls()
        }

        getCustomClickUrls() {
            return this.videoClicks.getCustomClicks()
        }

        getDuration() {
            return this.duration
        }

        getIndustryIcons() {
            return Object.assign([], this.icons)
        }

        getInteractiveCreative() {
            return this.interactiveCreative
        }

        getSkipOffset() {
            if (!this.skipOffset || "" === this.skipOffset) return -1;
            if (-1 !== this.skipOffset.indexOf("%")) {
                let t = parseFloat(this.skipOffset.substring(0, this.skipOffset.length - 1));
                return t ? Math.round(t * this.duration / 100) : (p.w("Invalid skipoffset string: " + this.skipOffset), -1)
            }
            return B(this.skipOffset, -1)
        }

        getTrackingMap() {
            return this.trackingMap
        }

        getTrackingReport(t) {
            return this.trackingMap.has(t) ? this.trackingMap.get(t) : null
        }

        initialiseInteractiveCreative(t) {
            this.interactiveCreative && this.interactiveCreative.initialise(this.getAdParameters(), this.duration, t)
        }

        isNonLinear() {
            return !1
        }

        isValid() {
            return this.duration > 0
        }

        onClickThrough() {
            let t = this.videoClicks.getClickTrackingUrls();
            if (t.length > 0) {
                let e = P(t, "ClickTracking");
                this.broker.fireTrackingReportForCreative(e, this)
            }
            this.broker.raiseTrackingCallbackForCreative("ClickTracking", this)
        }

        onTrackingEvent(t) {
            if ("customClick" !== t) return void p.w("Invalid tracking event: " + t);
            let e = this.videoClicks.getCustomClicks();
            if (e.length > 0) {
                let i = new D(t, e);
                this.broker.fireTrackingReportForCreative(i, this)
            } else {
                if (D.isValidPlayerOperationEvent(t)) return void p.w("Use PlaybackEventHandler functions to signal event " + t);
                if (D.isTimelineEvent(t)) return void p.w("Invalid event: " + t + ". Timeline events are signalled by position updates");
                let e = this.trackingMap.get(t);
                e && this.broker.fireTrackingReportForCreative(e, this)
            }
        }

        setDuration(t) {
            this.duration = t
        }

        toString() {
            let t = "";
            if (this.trackingMap.size > 0) {
                t += "\n ** Tracking events - ";
                for (let [e, i] of this.trackingMap) t += y("\n " + e + ":" + i)
            }
            let e = "";
            if (this.icons.length > 0) {
                e += "\n  ** Industry Icon(s) - ";
                for (let t of this.icons) e += t
            }
            let i = "\n--- Linear Creative:\n - assetUri:";
            return i += this.assetUri, this.interactiveCreative && (i += this.interactiveCreative), i += super.toString(), k(this.skipOffset) || (i += "\n - SkipOffset:", i += this.skipOffset), i += t, i += y(this.videoClicks), i += e, i
        }
    }

    class Q extends F {
        static buildMapString(t) {
            let e = "";
            if (t.size > 0) for (let [i, r] of t) e += "\n " + i + "=" + r
        }

        constructor(t) {
            super(), this.startMillis = 0, this.identifier = "", this.active = !1;
            let e = t.id;
            if (e) {
                let t = e.split("_YO_");
                2 === t.length && (this.identifier = t[0], this.mediaIdentifier = t[1])
            }
            this.properties = t.properties ? t.properties : [], this.linearCreative = t.linearCreative, this.nonLinearAds = t.nonLinearAds ? t.nonLinearAds : new x, this.companionAds = t.companionAds ? t.companionAds : new b, this.impressions = t.impressions, this.errors = t.errors, this.viewableImpressions = t.viewableImpressions ? t.viewableImpressions : new Map, this.adVerifications = t.adVerifications ? t.adVerifications : [], this.sequence = t.sequence, this.adType = t.adType, this.nonLinear = t.nonLinear, this.filler = t.filler, this.trackingSchedule = new Map, t.topLevelWrapper && t.topLevelWrapper.isValid() ? this.wrapper = t.topLevelWrapper : this.wrapper = null, this.extensions = t.extensions, this.broker = null, this.macroSubstitutions = new Map
        }

        addMacroSubstitution(t, e) {
            this.macroSubstitutions.set(t, e)
        }

        addTrackingScheduleEntry(t, e) {
            let i = e * this.linearCreative.getDuration();
            for (; this.trackingSchedule.has(i);) ++i;
            this.trackingSchedule.set(i, t)
        }

        adjustForEarlyReturn(t) {
            let e = t - this.startMillis;
            this.setDuration(e);
            let i = this.getTrackingSchedule();
            for (let t of i.keys()) t > e && this.removeFromTrackingSchedule(t)
        }

        clearTrackingSchedule() {
            this.trackingSchedule.clear()
        }

        containsCreative(t) {
            return t instanceof K ? t === this.linearCreative : t instanceof G ? this.nonLinearAds.containsCreative(t) : t instanceof _ && this.companionAds.containsCreative(t)
        }

        containsIcon(t) {
            for (let e of this.linearCreative.getIndustryIcons()) if (e === t) return !0;
            return !1
        }

        getAdVerifications() {
            return Object.assign([], this.adVerifications)
        }

        getAdType() {
            return this.adType
        }

        getCompanionAds() {
            return this.companionAds
        }

        getCompanionAdsByType(t) {
            return this.companionAds.getCompanionsByType(t)
        }

        getCompanionRequired() {
            return this.companionAds.getRequired()
        }

        getDuration() {
            return this.nonLinear ? 0 : this.linearCreative.getDuration()
        }

        getEnd() {
            return this.startMillis + this.linearCreative.getDuration()
        }

        getExtensions() {
            return this.extensions
        }

        getIdentifier() {
            return this.identifier
        }

        getImpressions(t) {
            if (!this.impressions) return null;
            let e = new D(this.impressions.trackingEvent, this.impressions.trackingUrls);
            return t && (this.impressions = null), e
        }

        getIndustryIcons() {
            return this.linearCreative.getIndustryIcons()
        }

        getInteractiveCreative() {
            return this.linearCreative.getInteractiveCreative()
        }

        getLineage() {
            return this.wrapper
        }

        getLinearCreative() {
            return this.linearCreative
        }

        getMacroSubstitutions() {
            return this.macroSubstitutions
        }

        getMediaIdentifier() {
            return this.mediaIdentifier
        }

        getNonLinearAds() {
            return this.nonLinearAds
        }

        getNonLinearCreativesByType(t) {
            return this.nonLinearAds.getNonLinearCreativesByType(t)
        }

        getProperties() {
            return Object.assign([], this.properties)
        }

        getProperty(t) {
            for (let e of this.properties) if (e.getName() === t) return e;
            return null
        }

        getProportion(t) {
            let e = 0, i = t.split("-");
            if (2 !== i.length) p.w("Badly formed progress event in VAST/VMAP: " + t), e = -1; else if (-1 !== i[1].indexOf("%")) {
                let t = parseFloat(i[1].substring(0, i[1].length - 1));
                e = t ? t / 100 : -1, e < 0 && p.w("Badly formed percentage string in VAST/VMAP: " + i[1])
            } else e = parseFloat(B(i[1], -1) / this.linearCreative.getDuration());
            return e
        }

        getRemainingTime(t) {
            let e = this.startMillis + this.linearCreative.getDuration(),
                i = Math.min(e - t, this.linearCreative.getDuration());
            return Math.max(0, i)
        }

        getSequence() {
            return this.sequence
        }

        getSkipOffset() {
            return this.linearCreative.getSkipOffset()
        }

        getStart() {
            return this.startMillis
        }

        getTrackingReports(t) {
            let e = [], i = this.linearCreative.getTrackingReport(t);
            return i && e.push(i), i = this.nonLinearAds.getTrackingReport(t), i && e.push(i), e
        }

        getTrackingReportLinear(t) {
            if (this.linearCreative) return this.linearCreative.getTrackingReport(t)
        }

        getTrackingReportNonLinear(t) {
            if (this.nonLinearAds) return this.nonLinearAds.getTrackingReport(t)
        }

        getTrackingSchedule() {
            return this.trackingSchedule
        }

        getViewableImpressions() {
            return this.viewableImpressions
        }

        isActive() {
            return this.active
        }

        isFiller() {
            return this.filler
        }

        isNonLinear() {
            return this.nonLinear
        }

        isValid() {
            return this.nonLinear ? !this.linearCreative : !k(this.mediaIdentifier) && null !== this.linearCreative
        }

        onErrorEvent(t) {
            this.errors && (t && this.addMacroSubstitution("ERRORCODE", t.toString()), this.broker.fireTrackingReport(this.errors))
        }

        onImpressionEvent() {
            if (!this.nonLinear) return void p.w("Warning: Advert is not nonlinear - can't signal ImpressionEvent");
            let t = this.getImpressions(!0);
            t && this.broker.fireTrackingReport(t)
        }

        onViewableEvent(t) {
            let e = Q.viewableEventMap.get(t), i = this.viewableImpressions.get(e);
            i && this.broker.fireTrackingReport(i)
        }

        postParse(t) {
            if (this.broker = t, !this.nonLinear) {
                this.addTrackingScheduleEntry("loaded", 0), this.addTrackingScheduleEntry("start", 0), this.addTrackingScheduleEntry("firstQuartile", .25), this.addTrackingScheduleEntry("midpoint", .5), this.addTrackingScheduleEntry("thirdQuartile", .75), this.addTrackingScheduleEntry("complete", 1);
                for (let [t, e] of this.linearCreative.getTrackingMap()) if (-1 !== t.indexOf("progress")) {
                    let i = this.getProportion(t, e);
                    i >= 0 && this.addTrackingScheduleEntry(t, i)
                }
            }
            for (let t of this.adVerifications) t.postParse(this.broker, t => {
                this.addMacroSubstitution("REASON", t.getPayload())
            });
            this.nonLinearAds.postParse(), this.linearCreative && this.linearCreative.initialiseInteractiveCreative(this.nonLinearAds.getNonLinearCreatives()), this.prefetchResources(t.getSessionProperties()), this.active = !0
        }

        prefetchResources(t) {
            t.getPrefetchResources() && (this.nonLinearAds.prefetchResources(), this.companionAds.prefetchResources())
        }

        removeFromTrackingSchedule(t) {
            this.trackingSchedule.delete(t)
        }

        removeMacroSubstitution(t) {
            this.macroSubstitutions.delete(t)
        }

        removeTrackingSchedule() {
            this.trackingSchedule.clear()
        }

        setDuration(t) {
            this.linearCreative && this.linearCreative.setDuration(t)
        }

        setInactive() {
            this.active = !1
        }

        setStart(t) {
            this.startMillis = t
        }

        toString() {
            if (this.isFiller()) return "\n--- Advert ---\n - Filler duration: " + this.getDuration();
            let t = "\n* Impression(s):";
            if (this.impressions) for (let e of this.impressions.getTrackingUrls()) t += e; else t += "NONE";
            let e = "\n* Viewable Impression(s):";
            e += Q.buildMapString(this.viewableImpressions);
            let i = "\n * Ad Verification(s):";
            i += y(this.adVerifications);
            let r = "\n Error(s):";
            if (this.errors) for (let t of this.errors.getTrackingUrls()) r += y("\n - " + t); else r += "NONE";
            let n = "\n--- Advert ---\n ID:";
            n += this.mediaIdentifier, n += "(", n += this.identifier, n += ")", n += " duration:", n += this.getDuration(), n += " sequence:", n += this.sequence, n += " adtype:", n += this.adType;
            for (let t of this.properties) n += "\n" + y(t);
            return this.extensions && (n += "\n * Extensions:", n += "\n" + y(this.getExtensions())), this.wrapper && (n += "\n * Lineage -\n", n += y(this.wrapper)), n += y(t), n += y(e), n += y(i), n += y(r), this.nonLinear || (n += y(this.linearCreative)), n += y(this.nonLinearAds), n += y(this.companionAds), n
        }
    }

    Q.viewableEventMap = new Map, Q.viewableEventMap.set(O.VIEWABLE, "Viewable"), Q.viewableEventMap.set(O.NOT_VIEWABLE, "NotViewable"), Q.viewableEventMap.set(O.VIEW_UNDETERMINED, "ViewUndetermined");
    const $ = Object.freeze({LINEAR: 0, NONLINEAR: 1, DISPLAY: 2});

    class J extends g {
        constructor(t, e, i, r, n, s, a) {
            super(), this.startMillis = t, this.duration = e, this.position = function (t) {
                let e = t ? t.toLowerCase() : "";
                return "preroll" === e || "midroll" === e || "postroll" === e ? e : "unknown"
            }(i), this.trackingMap = r || new Map, this.breakType = J.getBreakTypeFromString(n), this.identifier = s, this.extensions = a, this.broker = null, this.adverts = [], this.ended = !1
        }

        static getBreakTypeFromString(t) {
            return v(t, "nonlinear") ? $.NONLINEAR : v(t, "display") ? $.DISPLAY : $.LINEAR
        }

        adjustForEarlyReturn(t) {
            let e = this.getAdvertFromPlayhead(t);
            if (e) {
                let i = e.getStart() === t;
                return i || e.adjustForEarlyReturn(t), this.removeAdvertsFrom(e, i), this.setDuration(t - this.startMillis), !0
            }
            return !1
        }

        getAdvertForCreative(t) {
            for (let e of this.adverts) if (e.containsCreative(t)) return e;
            return null
        }

        getAdvertFromPlayhead(t) {
            for (let e of this.adverts) if (e.getStart() <= t && t < e.getEnd()) return e;
            return null
        }

        getAdvertFromIdentifier(t) {
            for (let e of this.adverts) if (e.getMediaIdentifier() === t) return e;
            return null
        }

        getAdverts() {
            return Object.assign([], this.adverts)
        }

        getBreakTypeAsString() {
            switch (this.breakType) {
                case $.NONLINEAR:
                    return "nonlinear";
                case $.DISPLAY:
                    return "display";
                default:
                    return "linear"
            }
        }

        getType() {
            return this.breakType
        }

        getDuration() {
            return this.duration
        }

        getExtensions() {
            return this.extensions
        }

        getIdentifier() {
            return this.identifier
        }

        getPosition() {
            return this.position
        }

        getRemainingTime(t) {
            let e = 0;
            if (this.adverts.length > 0) {
                let i = this.adverts[0].getStart() + this.getDuration();
                e = Math.min(i - t, this.getDuration())
            }
            return Math.max(0, e)
        }

        getStart() {
            return this.startMillis
        }

        getTrackingMap() {
            return this.trackingMap
        }

        getTrackingReport(t, e) {
            let i = this.trackingMap.get(t);
            return i && e && this.trackingMap.delete(t), i
        }

        isActive() {
            if (!this.adverts) return !1;
            for (let t of this.adverts) if (t.isActive()) return !0;
            return !1
        }

        isEnded() {
            return this.ended
        }

        isNonLinear() {
            return this.breakType !== $.LINEAR
        }

        isValid() {
            return this.adverts.length > 0 || this.trackingMap.size > 0
        }

        onNonLinearTrackingEvent(t) {
            if (!this.isNonLinear()) return void p.w("Warning: AdBreak is not nonlinear - can't signal NonLinearTrackingEvent");
            let e = this.getTrackingReport(t, !1);
            e && this.broker.fireTrackingReport(e)
        }

        postParse(t) {
            this.broker = t;
            let e = this.startMillis;
            for (let i of this.adverts) i.setStart(e), e += i.getDuration(), i.postParse(t)
        }

        removeAdvertsFrom(t, e) {
            for (let i = 0; i < this.adverts.length; ++i) {
                if (this.adverts[i] === t) {
                    let t = !0 === e ? i : i + 1;
                    return void this.adverts.splice(t, this.adverts.length - t)
                }
            }
        }

        setAdverts(t) {
            Array.prototype.push.apply(this.adverts, t);
            let e = this.startMillis;
            for (let t of this.adverts) t.setStart(e), e += t.getDuration()
        }

        setAdvertsInactivePriorTo(t) {
            for (let e of this.adverts) {
                if (!(e.getEnd() < t)) return !1;
                e.setInactive()
            }
            return !0
        }

        setDuration(t) {
            this.duration = t
        }

        setEnded() {
            this.ended = !0
        }

        setInactive() {
            if (!this.isNonLinear()) {
                for (let t of this.adverts) t.setInactive();
                this.trackingMap.clear(), this.setEnded()
            }
        }

        toString() {
            return `\n--- AdBreak ---\n breakType:${this.getBreakTypeAsString()} start:${this.startMillis} milliseconds, duration:${this.duration}, position:${this.position}\nNumber of adverts:${this.adverts.length}`
        }
    }

    class Z extends f {
        canStop() {
            throw new Error("Function must be overridden")
        }

        canPause() {
            throw new Error("Function must be overridden")
        }

        canSkip() {
            throw new Error("Function must be overridden")
        }

        willSeekTo(t) {
            throw new Error("Function must be overridden")
        }

        canChangeVolume(t) {
            throw new Error("Function must be overridden")
        }

        canResize(t) {
            throw new Error("Function must be overridden")
        }

        canResizeCreative(t) {
            throw new Error("Function must be overridden")
        }

        canClickThrough(t) {
            throw new Error("Function must be overridden")
        }
    }

    const tt = Object.freeze({
        START: 0,
        STOP: 1,
        PAUSE: 2,
        RESUME: 3,
        STALL: 4,
        CONTINUE: 5,
        ADVERT_REWIND: 6,
        ADVERT_SKIP: 7,
        SEEK: 8
    }), et = Object.freeze({COLLAPSED: 0, EXPANDED: 1});

    class it extends Z {
        onPlayerEvent(t, e) {
            throw new Error("Function must be overridden")
        }

        onPlayheadUpdate(t) {
            throw new Error("Function must be overridden")
        }

        onTimedMetadata(t) {
            throw new Error("Function must be overridden")
        }

        onViewSizeChange(t) {
            throw new Error("Function must be overridden")
        }

        onVolumeChange(t) {
            throw new Error("Function must be overridden")
        }
    }

    class rt extends it {
        fireTrackingReport(t) {
            throw new Error("Function must be overriden")
        }

        fireTrackingReportForCreative(t, e) {
            throw new Error("Function must be overriden")
        }

        fireTrackingReportForIcon(t, e) {
            throw new Error("Function must be overriden")
        }

        raiseTrackingCallbackForCreative(t, e) {
            throw new Error("Function must be overridden")
        }

        getSessionProperties() {
            throw new Error("Function must be overridden")
        }
    }

    class nt {
        onAdvertBreakStart(t) {
            throw new Error("Function must be overridden")
        }

        onAdvertBreakEnd() {
            throw new Error("Function must be overridden")
        }

        onAdvertBreakEarlyReturn(t) {
            throw new Error("Function must be overridden")
        }

        onAdvertEnd() {
            throw new Error("Function must be overridden")
        }

        onAdvertStart(t) {
            throw new Error("Function must be overridden")
        }

        onAnalyticUpdate() {
            throw new Error("Function must be overridden")
        }

        onTrackingEvent(t) {
            throw new Error("Function must be overridden")
        }

        onSessionTimeout() {
            throw new Error("Function must be overriden")
        }
    }

    class st {
        constructor(t) {
            this.properties = t, this.suppress = !1, this.observers = []
        }

        addAnalyticObserver(t) {
            t ? this.observers.push(t) : p.e("addAnalyticObserver: listener was null")
        }

        applyEncryptedTracking(t) {
            return this.properties.getApplyEncryptedTracking() && (t = t.replace("http:", "https:")), t
        }

        fire(t, e) {
            let i = {method: "GET"};
            this.properties.getAllowCorsForAnalytics() ? k(this.properties.getUserAgent()) || (i.headers = function (t) {
                let e = new Headers;
                return e.append("User-Agent", t), e
            }(this.properties.getUserAgent())) : i.mode = "no-cors";
            for (let r of t.getTrackingUrls()) this.performMacroSubstitutionForUrl(r, e), this.applyEncryptedTracking(r), p.d(o, "Firing report url: " + r), fetch(r, i).catch(() => {
            })
        }

        fireBeacon(t, e) {
            if (t && t.getTrackingUrls().length > 0 && !this.shouldSuppress(t.event)) try {
                this.fire(t, e)
            } catch (t) {
                throw p.e("Unable to fire tracking URLs for report: " + t), t
            }
        }

        fireBeacons(t, e) {
            let i = [];
            for (let e of t) for (let t of e.getTrackingUrls()) i.push(t);
            this.fireBeacon(new D("", i), e)
        }

        performMacroSubstitutionForUrl(t, e) {
            let i = "", r = (n = Date.now(), new Date(n).toISOString());
            var n;
            let s = U(e.getPlayhead()), a = -1 === e.getAdvertStart() ? "-1" : U(e.getAdvertStart());
            i = encodeURIComponent(e.getAssetUri()), r = encodeURIComponent(r), s = encodeURIComponent(s), a = encodeURIComponent(a);
            let o = 1e7 + Math.round(1e8 * Math.random());
            t = t.replace("[ASSETURI]", i).replace("%5BASSETURI%5D", i).replace("[CACHEBUSTING]", o).replace("%5BCACHEBUSTING%5D", o).replace("[TIMESTAMP]", r).replace("%5BTIMESTAMP%5D", r).replace("[CONTENTPLAYHEAD]", s).replace("%5BCONTENTPLAYHEAD%5D", s).replace("[MEDIAPLAYHEAD]", s).replace("%5BMEDIAPLAYHEAD%5D", s).replace("[ADPLAYHEAD]", a).replace("%5BADPLAYHEAD%5D", a);
            for (let [i, r] of e.getMacroSubstitutions()) t = t.replace(`[${i}]`, r).replace(`%5B${i}%5D`, r);
            return t = (t = t.replace(/\[(.*?)]/g, "-1")).replace(/%5B(.*)%5D/g, "-1")
        }

        raiseAdBreakEarlyReturn(t) {
            for (let e of this.observers) e.onAdvertBreakEarlyReturn(t)
        }

        raiseAdBreakCallback(t, e) {
            if ("start" === t) for (let t of this.observers) t.onAdvertBreakStart(e); else if ("end" === t) for (let t of this.observers) t.onAdvertBreakEnd()
        }

        raiseAdvertCallback(t, e) {
            if ("start" === t) for (let t of this.observers) t.onAdvertStart(e); else if ("end" === t) for (let t of this.observers) t.onAdvertEnd()
        }

        raiseAnalyticUpdateCallback() {
            if (!this.suppress) for (let t of this.observers) t.onAnalyticUpdate()
        }

        raiseSessionTimeoutCallback() {
            for (let t of this.observers) t.onSessionTimeout()
        }

        raiseTrackingCallback(t) {
            if (!this.shouldSuppress(t)) for (let e of this.observers) e.onTrackingEvent(t)
        }

        removeAnalyticObserver(t) {
            this.observers.splice(this.observers.indexOf(t))
        }

        reportsSuppressed() {
            return this.suppress
        }

        shouldSuppress(t) {
            let e = D.categoryForEvent(t);
            return 0 == (this.properties.getExcludedCategories() & e) && this.suppress
        }

        suppressReports(t) {
            this.suppress !== t && (this.suppress = t, p.d(o, t ? "Suppress reports" : "Unsuppress reports"))
        }
    }

    class at {
        constructor(t, e, i, r) {
            this.playhead = t, this.advertStart = e && e >= 0 ? t - e : -1, this.assetUri = i || "", this.macroSubstitutions = r || new Map
        }

        getAdvertStart() {
            return this.advertStart
        }

        getAssetUri() {
            return this.assetUri
        }

        getMacroSubstitutions() {
            return this.macroSubstitutions
        }

        getPlayhead() {
            return this.playhead
        }
    }

    var ot = i(18);
    const lt = Object.freeze({LIVE: 0, DVRLIVE: 1, VOD: 2}),
        ht = Object.freeze({NOT_INITIALISED: 0, INITIALISED: 1, FAILED: 2, NO_ANALYTICS: 3, TIMEOUT: 4}), ct = -1,
        ut = -2, dt = -3, pt = -20;

    class ft extends rt {
        constructor(t) {
            super(), p.logger.debug("Yospace AdManagement SDK for JavaScript v" + ot.version), this.sessionProperties = t ? Object.assign(Object.create(Object.getPrototypeOf(t)), t) : new gt, this.reportsManager = new st(t), this.linearAdBreaks = [], this.nonLinearAdBreaks = [], this.displayAdBreaks = [], this.playbackBuffering = !1, this.playing = !1, this.currentAdBreak = null, this.currentAdvert = null, this.identifier = "", this.playbackUrl = null, this.analyticsUrl = null, this.lastAnalyticUpdate = null, this.playhead = 0, this.lastPlayed = 0, this.lastTraced = 0, this.sessionResult = ht.NOT_INITIALISED, this.resultCode = 0, this.policyHandler = null
        }

        addAnalyticObserver(t) {
            t ? this.reportsManager.addAnalyticObserver(t) : p.e("addAnalyticObserver: observer was null")
        }

        analyticsSuppressed() {
            return this.reportsManager.reportsSuppressed()
        }

        canChangeVolume(t) {
            return !this.policyHandler || this.policyHandler.canChangeVolume(t, this.playhead, this.linearAdBreaks)
        }

        canClickThrough(t) {
            return !this.policyHandler || this.policyHandler.canClickThrough(t, this.playhead, this.linearAdBreaks)
        }

        canPause() {
            return !this.policyHandler || this.policyHandler.canPause(this.playhead, this.linearAdBreaks)
        }

        canResize(t) {
            return !this.policyHandler || this.policyHandler.canResize(t, this.playhead, this.linearAdBreaks)
        }

        canResizeCreative(t) {
            return !this.policyHandler || this.policyHandler.canResizeCreative(t, this.playhead, this.linearAdBreaks)
        }

        canSkip() {
            return this.policyHandler ? this.policyHandler.canSkip(this.playhead, this.linearAdBreaks, 0) : 0
        }

        canStop() {
            return !this.policyHandler || this.policyHandler.canStop(this.playhead, this.linearAdBreaks)
        }

        completeWithStatus(t, e) {
            this.setState(t), this.setResultCode(e), t === ht.INITIALISED && p.trace("sessionStart")
        }

        fireImpressionReport() {
            let t = this.currentAdvert;
            if (t && t.isActive()) {
                let e = t.getImpressions(!0);
                if (e) {
                    let i = new D(e.trackingEvent, e.trackingUrls),
                        r = new at(this.getPlayhead(), t.getStart(), t.getLinearCreative().getAssetUri(), t.getMacroSubstitutions());
                    this.reportsManager.fireBeacon(i, r), e.removeTrackingUrls()
                }
            }
        }

        fireTrackingReport(t) {
            let e = null, i = null, r = null, n = this.getCurrentAdvert();
            n && (e = n.getStart(), n.getLinearCreative() && (i = n.getLinearCreative().getAssetUri()), r = n.getMacroSubstitutions()), p.trace("trackingEvent " + t.getEventType());
            let s = new at(this.getPlayhead(), e, i, r);
            this.reportsManager.fireBeacon(t, s)
        }

        fireTrackingReportForCreative(t, e) {
            let i = null, r = this.getAdvertForCreative(e);
            if (r) {
                r.getLinearCreative() && (i = r.getLinearCreative().getAssetUri()), p.trace("trackingEvent " + t.getEventType());
                let e = new at(this.getPlayhead(), r.getStart(), i, r.getMacroSubstitutions());
                this.reportsManager.fireBeacon(t, e)
            }
        }

        fireTrackingReportForIcon(t, e) {
            let i = null, r = this.currentAdvert;
            if (r && r.isActive() && r.containsIcon(e)) {
                r.getLinearCreative() && (i = r.getLinearCreative().getAssetUri()), p.trace("trackingEvent " + t.getEventType());
                let e = new at(this.getPlayhead(), r.getStart(), i, r.getMacroSubstitutions());
                this.reportsManager.fireBeacon(t, e)
            }
        }

        getAdBreaksByType(t) {
            switch (t) {
                case $.LINEAR:
                    return Object.assign([], this.linearAdBreaks);
                case $.NONLINEAR:
                    return Object.assign([], this.nonLinearAdBreaks);
                case $.DISPLAY:
                    return Object.assign([], this.displayAdBreaks);
                default:
                    return null
            }
        }

        getAnalyticsUrl() {
            return this.analyticsUrl
        }

        getAdvertForCreative(t) {
            let e = this.currentAdvert;
            if (e && e.isActive() && e.getLinearCreative() === t) return e;
            if (t.isNonLinear()) {
                for (let i of this.nonLinearAdBreaks) if (e = i.getAdvertForCreative(t), e) return e;
                for (let i of this.displayAdBreaks) if (e = i.getAdvertForCreative(t), e) return e
            } else if (!(t instanceof K)) for (let i of this.linearAdBreaks) if (e = i.getAdvertForCreative(t), e) return e;
            return null
        }

        getCurrentAdBreak() {
            return this.currentAdBreak
        }

        getCurrentAdvert() {
            return this.currentAdvert
        }

        getIdentifier() {
            return this.identifier
        }

        getPlaybackMode() {
            throw new Error("This must be overridden")
        }

        getPlaybackUrl() {
            return this.playbackUrl
        }

        getPlayhead() {
            return this.playhead
        }

        getRequestTimeout() {
            return this.requestTimeout
        }

        getResultCode() {
            return this.resultCode
        }

        getLastAnalyticUpdate() {
            return this.lastAnalyticUpdate
        }

        getLastPlayed() {
            return this.lastPlayed
        }

        getReportsManager() {
            return this.reportsManager
        }

        getSessionProperties() {
            return Object.freeze(this.sessionProperties)
        }

        getSessionResult() {
            return this.sessionResult
        }

        isNotPlaying() {
            return !this.playing
        }

        isPlaybackBuffering() {
            return this.playbackBuffering
        }

        onAdvertSkip(t) {
            this.signalActionTrackingEvent("skip"), this.policyHandler && this.policyHandler.didSkip(this.playhead, t, this.linearAdBreaks), this.playhead = t
        }

        onPlaybackContinue() {
            this.playbackBuffering ? (this.playbackBuffering = !1, p.trace("playbackEvent continue")) : p.d(n, "Reporting CONTINUE when not buffering")
        }

        onPlayerEvent(t, e) {
            switch (p.d(n, "New playback event: " + t + " at: " + e), t) {
                case tt.START:
                    this.onPlaybackStart(e);
                    break;
                case tt.STOP:
                    this.onPlaybackStop();
                    break;
                case tt.PAUSE:
                    this.onPlaybackPause();
                    break;
                case tt.RESUME:
                    this.onPlaybackResume();
                    break;
                case tt.STALL:
                    this.onPlaybackStall();
                    break;
                case tt.CONTINUE:
                    this.onPlaybackContinue();
                    break;
                case tt.ADVERT_REWIND:
                    this.onPlaybackRewind(e);
                    break;
                case tt.ADVERT_SKIP:
                    this.onAdvertSkip(e);
                    break;
                case tt.SEEK:
                    this.onPlaybackSeek(e);
                    break;
                default:
                    p.w("Unknown playback event: " + t)
            }
            p.d(n, "Playing: " + this.playing + ", Buffering: " + this.playbackBuffering)
        }

        onPlaybackPause() {
            this.playing ? (this.playing = !1, this.signalActionTrackingEvent("pause")) : p.d(n, "Reporting PAUSE when already paused")
        }

        onPlaybackResume() {
            this.playing ? p.d(n, "Reporting RESUME when already paying") : (this.playing = !0, this.signalActionTrackingEvent("resume"))
        }

        onPlaybackRewind(t) {
            this.signalActionTrackingEvent("rewind"), this.playhead = t
        }

        onPlaybackSeek(t) {
            this.policyHandler && this.policyHandler.didSeek(this.playhead, t, this.linearAdBreaks), p.trace("playbackEvent seek: " + t), this.playhead = t
        }

        onPlaybackStall() {
            this.playing && !this.playbackBuffering ? (this.playbackBuffering = !0, p.trace("playbackEvent stall")) : p.d(n, "Reporting STALL when not buffering")
        }

        onPlaybackStart(t) {
            this.playing ? p.d(n, "Reporting START when already playing") : (this.playing = !0, p.trace("playbackEvent start"))
        }

        onPlaybackStop() {
            if (this.playing) {
                this.playing = !1, this.playbackBuffering = !1, p.trace("playbackEvent stop");
                let t = this.currentAdvert;
                if (t) {
                    let e = t.getLinearCreative();
                    if (e) {
                        let t = e.getTrackingReport("closeLinear");
                        t && this.fireTrackingReport(t)
                    }
                }
            }
        }

        onPlayheadSeek(t) {
            this.policyHandler && this.policyHandler.didSeek(this.playhead, t, this.linearAdBreaks), p.trace("playbackEvent seek: " + t), this.playhead = t
        }

        onPlayheadUpdate(t) {
            (0 === this.lastTraced || t < this.lastTraced || t - this.lastTraced >= 5e3) && (p.trace("sdk playhead: " + t), this.lastTraced = t), this.lastPlayed = this.playhead, this.playhead = t
        }

        onTimedMetadata(t) {
        }

        onViewSizeChange(t) {
            switch (t) {
                case et.EXPANDED:
                    this.signalActionTrackingEvent("playerExpand");
                    break;
                case et.COLLAPSED:
                    this.signalActionTrackingEvent("playerCollapse");
                    break;
                default:
                    p.w("Unknown ViewSize: " + t)
            }
        }

        onVolumeChange(t) {
            let e = t ? "mute" : "unmute";
            this.signalActionTrackingEvent(e)
        }

        raiseTrackingCallbackForCreative(t, e) {
            this.getAdvertForCreative(e) && (p.trace("trackingEvent " + t), this.getReportsManager().raiseTrackingCallback(t))
        }

        removeAllNonLinearAdBreaks() {
            this.nonLinearAdBreaks = [], this.displayAdBreaks = []
        }

        removeAnalyticObserver(t) {
            this.reportsManager.removeAnalyticObserver(t)
        }

        removeNonLinearAdBreak(t) {
            for (let e = 0; e < this.nonLinearAdBreaks.length; ++e) {
                if (this.nonLinearAdBreaks[e] === t) return void this.nonLinearAdBreaks.splice(e, 1)
            }
            for (let e = 0; e < this.displayAdBreaks.length; ++e) {
                if (this.displayAdBreaks[e] === t) return void this.displayAdBreaks.splice(e, 1)
            }
        }

        removeKeysFromTrackingSchedule(t) {
            for (let e of t) this.currentAdvert.removeFromTrackingSchedule(e)
        }

        setAnalyticsUrl(t) {
            this.analyticsUrl = t
        }

        setCurrentAdBreak(t) {
            this.currentAdBreak = t
        }

        setCurrentAdvert(t) {
            this.currentAdvert = t
        }

        setIdentifier(t) {
            this.identifier = t
        }

        setLastAnalyticUpdate(t) {
            this.lastAnalyticUpdate = t
        }

        setPlaybackPolicyHandler(t) {
            this.policyHandler = t, this.policyHandler && this.policyHandler.setPlaybackMode(this.getPlaybackMode())
        }

        setPlaybackUrl(t) {
            this.playbackUrl = t
        }

        setPlayhead(t) {
            this.playhead = t
        }

        setReportsManager(t) {
            this.reportsManager = t
        }

        setResultCode(t) {
            this.resultCode = t
        }

        setState(t) {
            this.sessionResult = t
        }

        shutdown() {
            p.d(s, "Session shutdown"), this.onPlaybackStop(), p.trace("sessionEnd")
        }

        signalActionTrackingEvent(t) {
            let e = this.currentAdvert;
            if (e && e.isActive() && !e.isFiller() && !k(t)) {
                p.trace("actionEvent " + t);
                let i = e.getTrackingReports(t),
                    r = new at(this.getPlayhead(), e.getStart(), e.getLinearCreative().getAssetUri(), e.getMacroSubstitutions());
                i.length > 0 && this.reportsManager.fireBeacons(i, r), "closeLinear" !== t && this.reportsManager.raiseTrackingCallback(t)
            }
        }

        signalNonLinearTrackingEvent(t) {
            let e = this.currentAdvert;
            if (e && e.isActive() && !e.isFiller() && !k(t)) {
                p.trace("nonlinearTrackingEvent " + t);
                let i = e.getTrackingReportLinear(t);
                if (i) {
                    let t = new at(this.getPlayhead(), e.getStart(), e.getLinearCreative().getAssetUri(), e.getMacroSubstitutions());
                    this.reportsManager.fireBeacon(i, t)
                }
                this.reportsManager.raiseTrackingCallback(t)
            }
        }

        signalTimelineTrackingEvents(t) {
            let e = this.currentAdvert;
            if (e && e.isActive() && !e.isFiller()) {
                let i = new at(this.getPlayhead(), e.getStart(), e.getLinearCreative().getAssetUri(), e.getMacroSubstitutions()),
                    n = [];
                for (let [s, a] of e.getTrackingSchedule()) if (t + r.e.EVENT_CUEPOINT_TOL >= s) {
                    p.d(o, "Tracking schedule entry retrieved: " + a), n.push(s);
                    let t = e.getTrackingReportLinear(a);
                    t && this.reportsManager.fireBeacon(t, i);
                    let r = -1 !== a.indexOf("progress") ? "progress" : a;
                    p.trace("timelineEvent " + r), this.reportsManager.raiseTrackingCallback(r)
                }
                this.removeKeysFromTrackingSchedule(n)
            }
        }

        signalTrackingEvent(t, e) {
            let i = this.currentAdvert;
            if (i && i.isActive() && !i.isFiller() && !k(t)) {
                if (p.trace("trackingEvent" + t), e) {
                    let t = new at(this.getPlayhead(), i.getStart(), i.getLinearCreative().getAssetUri(), i.getMacroSubstitutions());
                    this.reportsManager.fireBeacon(e, t)
                }
                this.reportsManager.raiseTrackingCallback(t)
            }
        }

        suppressAnalytics(t) {
            if (this.reportsManager.suppressReports(t), !t && this.currentAdBreak) {
                let t = this.currentAdBreak.getTrackingReport("breakStart", !0);
                this.getReportsManager().fireBeacon(t, new at(this.getPlayhead()))
            }
        }

        willSeekTo(t) {
            return this.policyHandler ? this.policyHandler.willSeekTo(t, this.linearAdBreaks, this.getPlayhead()) : t
        }
    }

    class gt {
        constructor(t) {
            this.requestTimeout = t && t.requestTimeout ? t.requestTimeout : r.e.REQUEST_TIMEOUT, this.userAgent = t ? t.userAgent : "", this.prefetchResources = !!t && t.prefetchResources, this.fireHistoricalBeacons = !t || t.fireHistoricalBeacons, this.eventCategories = t ? t.eventCategories : 0, this.allowCorsForAnalytics = !!t && t.allowCorsForAnalytics, this.setCustomHttpHeaders(t ? t.customHttpHeaders : null), this.useHttps = !!t && t.useHttps
        }

        excludeFromSuppression(t) {
            this.eventCategories = t
        }

        getCustomHttpHeaders() {
            return this.customHttpHeaders
        }

        getExcludedCategories() {
            return this.eventCategories
        }

        getFireHistoricalBeacons() {
            return this.fireHistoricalBeacons
        }

        getPrefetchResources() {
            return this.prefetchResources
        }

        getRequestTimeout() {
            return this.requestTimeout
        }

        getUserAgent() {
            return this.userAgent
        }

        getAllowCorsForAnalytics() {
            return this.allowCorsForAnalytics
        }

        getApplyEncryptedTracking() {
            return this.useHttps
        }

        setAllowCorsForAnalytics(t) {
            this.allowCorsForAnalytics = t
        }

        setApplyEncryptedTracking(t) {
            this.useHttps = t
        }

        setCustomHttpHeaders(t) {
            if (t) for (let [e] of t) "USER-AGENT" === e.toUpperCase() && (p.w("SessionProperties: 'User-Agent' ignored"), t.delete(e)); else t = null;
            this.customHttpHeaders = t
        }

        setFireHistoricalBeacons(t) {
            this.fireHistoricalBeacons = t
        }

        setPrefetchResources(t) {
            this.prefetchResources = t
        }

        setRequestTimeout(t) {
            this.requestTimeout = t
        }

        setUserAgent(t) {
            this.userAgent = t
        }
    }

    class vt {
        canStop(t, e) {
            throw new Error("Must be overridden")
        }

        canPause(t, e) {
            throw new Error("Must be overridden")
        }

        canSkip(t, e, i) {
            throw new Error("Must be overridden")
        }

        willSeekTo(t, e, i) {
            throw new Error("Must be overridden")
        }

        canChangeVolume(t, e, i) {
            throw new Error("Must be overridden")
        }

        canResize(t, e, i) {
            throw new Error("Must be overridden")
        }

        canResizeCreative(t, e, i) {
            throw new Error("Must be overridden")
        }

        canClickThrough(t, e, i) {
            throw new Error("Must be overridden")
        }

        setPlaybackMode(t) {
            throw new Error("Must be overridden")
        }

        didSkip(t, e, i) {
            throw new Error("Must be overridden")
        }

        didSeek(t, e, i) {
            throw new Error("Must be overridden")
        }
    }

    var mt = i(8), yt = i.n(mt);

    class kt {
        constructor(t, e) {
            if (t) {
                this.linearAdBreaks = t.linearAdBreaks ? t.linearAdBreaks : [], this.nonLinearAdBreaks = t.nonLinearAdBreaks ? t.nonLinearAdBreaks : [], this.displayAdBreaks = t.displayAdBreaks ? t.displayAdBreaks : [], this.earlyReturn = t.earlyReturn;
                let e = t.getStreamData();
                this.processStreamData(e)
            }
            this.setHash(e)
        }

        getDisplayAdBreaks() {
            return this.displayAdBreaks
        }

        getEarlyReturn() {
            return this.earlyReturn
        }

        getLinearAdBreaks() {
            return this.linearAdBreaks
        }

        getHostNode() {
            return this.hostNode
        }

        getHostSuffix() {
            return this.hostSuffix
        }

        getNonLinearAdBreaks() {
            return this.nonLinearAdBreaks
        }

        getPdtInitial() {
            return this.pdtInitial
        }

        getPdtStart() {
            return this.pdtStart
        }

        getPdtEnd() {
            return this.pdtEnd
        }

        getSessionIdentifier() {
            return this.sessionIdentifier
        }

        getStreamDuration() {
            return this.streamDuration
        }

        hasAdBreaks() {
            return this.linearAdBreaks.length > 0 || this.nonLinearAdBreaks.length > 0 || this.displayAdBreaks.length > 0
        }

        isEqualTo(t) {
            return this.hashCode === t.hashCode
        }

        processStreamData(t) {
            this.sessionIdentifier = t.getSessionIdentifier(), this.streamDuration = t.getDuration(), this.hostNode = t.getHostNode(), this.hostSuffix = t.getHostSuffix(), this.pdtInitial = t.getPdtInitial(), this.pdtStart = t.getPdtStart(), this.pdtEnd = t.getPdtEnd()
        }

        setHash(t) {
            if (!t) return;
            let e, i, r = 0;
            for (e = 0; e < t.length; e++) i = t.charCodeAt(e), r = (r << 5) - r + i, r &= r;
            this.hashCode = r
        }

        toString() {
            let t = "Linear AdBreaks:";
            for (let e of this.linearAdBreaks) t += "\n" + e;
            t += "\n\nNonLinear AdBreaks:";
            for (let e of this.nonLinearAdBreaks) t += "\n" + e;
            t += "\n\nDisplay AdBreaks:";
            for (let e of this.displayAdBreaks) t += "\n" + e;
            return t += "\n\nHostNode:", t += "\n" + this.hostNode, t += "\n\nHostSuffix:", t += "\n" + this.hostSuffix, t += "\n\nSessionIdentifier:", t += "\n" + this.sessionIdentifier, t += "\n\nStreamDuration:", t += "\n" + this.streamDuration, t += "\n\npdtInitial:", t += "\n" + this.pdtInitial, t += "\n\npdtStart:", t += "\n" + this.pdtStart, t += "\n\npdtEnd:", t += "\n" + this.pdtEnd, t += "mmearlyReturn:", t += "\n" + this.earlyReturn, t
        }
    }

    function Tt(t) {
        let e = new Map;
        if (t) for (let i in t) e.set(i, t[i]);
        return e
    }

    const At = 0, Et = 1, bt = 2, wt = 3;

    class St {
        constructor() {
            this.clear()
        }

        clear() {
            this.adverts = [], this.timelineTrackingMap = new Map, this.trackingEvent = null, this.start = 0, this.duration = 0, this.position = null, this.breakType = null, this.identifier = null, this.earlyReturn = null
        }
    }

    class Ct {
        constructor() {
            this.clear()
        }

        clear() {
            this.id = null, this.sequence = null, this.adType = null, this.properties = [], this.linearCreative = null, this.companionAds = null, this.impressions = null, this.errors = null, this.viewableImpressions = new Map, this.adVerifications = [], this.filler = !1, this.nonLinear = !1, this.topLevelWrapper = null, this.extensions = null, this.currentCreativeType = At, this.nonLinearAds = null, this.adSystemVersion = null, this.advertiserId = null, this.categoryAuthority = null, this.pricingModel = null, this.pricingCurrency = null, this.surveyType = null, this.verificationVendor = null, this.verificationEvents = new Map, this.verificationResources = [], this.verificationApiFramework = null, this.verificationBrowserOptional = null, this.verificationParameters = null, this.verificationResourceType = null, this.extensionStack = []
        }
    }

    class It {
        constructor() {
            this.clear()
        }

        clear() {
            this.required = null, this.companions = []
        }
    }

    class Dt {
        constructor() {
            this.clearAll()
        }

        clear() {
            this.clickThroughUrl = "", this.clickThroughTrackings = [], this.clickThroughCustoms = [], this.nonLinearResources = [], this.duration = null, this.trackingMap = new Map, this.interactiveTracking = null, this.icons = [], this.currentAssetUri = null, this.skipOffset = null, this.adParameters = null, this.staticResourceCreativeType = null, this.trackingEvent = null, this.htmlResourceEncoded = !1, this.altText = null, this.companionExtensionStack = [], this.companionExtensions = null, this.icSource = null, this.properties = []
        }

        clearAll() {
            this.advertId = null, this.id = null, this.sequence = null, this.universalAdIds = [], this.universalAdIdRegistry = null, this.extensions = null, this.extensionStack = [], this.clickThroughTrackings = [], this.clickThroughUrl = "", this.adParameters = null, this.trackingEvent = null, this.duration = null, this.trackingMap = new Map, this.interactiveTracking = null, this.icons = [], this.currentAssetUri = null, this.skipOffset = null, this.clickThroughCustoms = [], this.nonLinearResources = [], this.staticResourceCreativeType = null, this.htmlResourceEncoded = null, this.altText = null, this.companionExtensions = null, this.companionExtensionStack = [], this.properties = [], this.icSource = null
        }
    }

    class Pt {
        constructor() {
            this.clear()
        }

        clear() {
            this.resources = [], this.properties = [], this.clickThroughUrl = null, this.staticResourceCreativeType = null, this.clickTrackings = [], this.clickFallbackImages = [], this.viewTrackings = [], this.htmlResourceEncoded = !1
        }
    }

    class Rt {
        constructor() {
            this.clear()
        }

        clear() {
            this.properties = [], this.resource = null, this.staticResourceCreativeType = null, this.altText = null
        }
    }

    class Lt {
        constructor() {
            this.clear()
        }

        clear() {
            this.nonLinearCreatives = [], this.trackingMap = new Map
        }
    }

    class Nt {
        constructor() {
            this.sessionIdentifier = null, this.duration = 0, this.hostNode = null, this.hostSuffix = null, this.pdtInitial = null, this.pdtStart = null, this.pdtEnd = null, this.earlyReturn = null
        }

        getSessionIdentifier() {
            return this.sessionIdentifier
        }

        getDuration() {
            return this.duration
        }

        getHostNode() {
            return this.hostNode
        }

        getHostSuffix() {
            return this.hostSuffix
        }

        getPdtInitial() {
            return this.pdtInitial
        }

        getPdtStart() {
            return this.pdtStart
        }

        getPdtEnd() {
            return this.pdtEnd
        }
    }

    class _t {
        constructor(t) {
            this.broker = t, this.linearAdBreaks = [], this.nonLinearAdBreaks = [], this.displayAdBreaks = [], this.isVmap = !1, this.isValidVAST = !0, this.processingAdvertExtensions = !1, this.processingCreativeExtensions = !1, this.characters = "", this.adBreakData = new St, this.advertData = new Ct, this.companionAdsData = new It, this.creativeData = new Dt, this.iconClickFallbackImageData = new Rt, this.iconData = new Pt, this.iconFallbackImageData = new Rt, this.nonLinearAdsData = new Lt, this.streamData = new Nt, this.onCdata = this.onCdata.bind(this), this.onOpenTag = this.onOpenTag.bind(this), this.onCloseTag = this.onCloseTag.bind(this), this.onText = this.onText.bind(this)
        }

        addToCreativeExtensionStack(t) {
            this.advertData.currentCreativeType === Et ? this.creativeData.companionExtensionStack.push(t) : this.creativeData.extensionStack.push(t)
        }

        checkValidVersion(t) {
            let e = parseFloat(t);
            return !Number.isNaN(e) && e >= 4.2
        }

        getStreamData() {
            return this.streamData
        }

        handleCreativeExtensionsForOnEndDefault(t) {
            let e = this.advertData.currentCreativeType === Et ? this.creativeData.companionExtensionStack : this.creativeData.extensionStack,
                i = e.length;
            if (2 === i) this.pop(!1, !0), this.processingCreativeExtensions = !1; else if (i > 0) {
                t === e[i - 1].getName() && this.pop(!1, !0)
            }
        }

        handleStartAd(t, e) {
            this.advertData.id = e.id;
            let i = parseInt(e.sequence);
            this.advertData.sequence = Number.isNaN(i) ? 0 : i, Number.isNaN(i) || (this.advertData.sequence = i), this.advertData.adType = e.adType, J.getBreakTypeFromString(this.adBreakData.breakType) !== $.LINEAR && (this.advertData.nonLinear = !0)
        }

        handleStartAdWrapper(t, e) {
            let i = e.id ? e.id : "", r = e.creativeId ? e.creativeId : "", n = e.AdSystem ? e.AdSystem : "",
                s = new q(i, r, n);
            this.advertData.topLevelWrapper && s.setChild(this.advertData.topLevelWrapper), this.advertData.topLevelWrapper = s
        }

        handleStartCreative(t, e) {
            this.creativeData.advertId = e.adId, this.creativeData.id = e.id;
            let i = parseInt(e.sequence);
            this.creativeData.sequence = isNaN(i) ? 0 : i
        }

        handleStartCreativeExtension(t, e) {
            let i = e.type;
            i = i || "", -1 === i.indexOf("com.yospace") && -1 === i.indexOf("AdVerifications") && (this.processingCreativeExtensions = !0, this.addToCreativeExtensionStack(new S(t.name, Tt(e))))
        }

        handleStartExtension(t, e) {
            let i = e.type;
            i = i || "", -1 === i.indexOf("com.yospace") && -1 === i.indexOf("AdVerifications") && (this.processingAdvertExtensions = !0, this.advertData.extensionStack.push(new S(t.name, Tt(e))))
        }

        handleStartExtensionElement(t, e) {
            this.processingAdvertExtensions ? this.advertData.extensionStack.push(new S(t.name, Tt(e))) : this.processingCreativeExtensions && this.addToCreativeExtensionStack(new S(t.name, Tt(e)))
        }

        handleStartHtmlResource(t) {
            let e = t.xmlEncoded, i = !!e && ("TRUE" === e.toUpperCase() || "1" === e);
            this.iconData.properties.length > 0 ? this.iconData.htmlResourceEncoded = i : this.creativeData.htmlResourceEncoded = i
        }

        handleStartPricing(t, e) {
            let i = e.model;
            this.advertData.pricingModel = i ? i.toUpperCase() : "", this.advertData.pricingCurrency = e.currency
        }

        handleStartStaticResource(t) {
            this.iconClickFallbackImageData.properties.length > 0 ? this.iconClickFallbackImageData.staticResourceCreativeType = t.creativeType : this.iconData.properties.length > 0 ? this.iconData.staticResourceCreativeType = t.creativeType : this.creativeData.staticResourceCreativeType = t.creativeType
        }

        handleStartTracking(t) {
            if (this.creativeData.trackingEvent = t.event, "progress" === this.creativeData.trackingEvent) {
                let e = t.offset;
                k(e) || (this.creativeData.trackingEvent = this.creativeData.trackingEvent + "-" + e)
            }
        }

        handleEndAd() {
            let t = new Q(this.advertData);
            t.isValid() ? this.adBreakData.adverts.push(t) : p.w("Invalid advert.  Discarding (" + this.advertData.id + ")"), this.advertData.clear()
        }

        handleAdvertExtensionsForOnEndDefault(t) {
            let e = this.advertData.extensionStack.length;
            if (2 === e) this.pop(!0, !0), this.processingAdvertExtensions = !1; else if (e > 0) {
                t === this.advertData.extensionStack[e - 1].getName() && this.pop(!0, !0)
            }
        }

        handleEndAdTitle() {
            let t = this.characters.trim();
            this.advertData.properties.push(new N("AdTitle", t)), "filler" === t && (this.advertData.filler = !0)
        }

        handleEndClickTracking() {
            let t = this.characters.trim();
            z(t) ? this.creativeData.clickThroughTrackings.push(t) : p.w("Discarding click tracking URL:" + t)
        }

        handleEndCompanion() {
            let t = null;
            k(this.creativeData.clickThroughUrl) || (t = new I(this.creativeData.clickThroughUrl, this.creativeData.clickThroughTrackings, null));
            let e = new _(this.creativeData, t, this.creativeData.nonLinearResources, this.creativeData.trackingMap, this.broker);
            e.isValid() ? (e.setNonLinear(this.advertData.nonLinear), this.companionAdsData.companions.push(e)) : p.w("Discarding invalid Companion"), this.creativeData.clear()
        }

        handleEndCompanionClickTracking() {
            let t = this.characters.trim();
            z(t) ? this.creativeData.clickThroughTrackings.push(t) : p.w("Discarding empty Companion click tracking URL")
        }

        handleEndCreative() {
            this.creativeData.clearAll()
        }

        handleEndCustomClick() {
            let t = this.characters.trim();
            "" !== t ? this.creativeData.clickThroughCustoms.push(t) : p.w("Discarding empty custom click URL")
        }

        handleEndError(t) {
            let e = this.characters.trim();
            z(e) ? this.advertData.errors ? this.advertData.errors.addTrackingUrl(e) : this.advertData.errors = new D(t, [e]) : p.w("Discarding empty Error")
        }

        handleEndExecutableResource() {
            if (this.advertData.verificationApiFramework && this.advertData.verificationResourceType) {
                let t = new N("ExecutableResource", this.characters.trim(), "apiFramework", this.advertData.verificationApiFramework);
                t.addAttribute("type", this.advertData.verificationResourceType), this.advertData.verificationResources.push(t)
            }
            this.advertData.verificationApiFramework = null, this.advertData.verificationResourceType = null
        }

        handleEndIcon() {
            let t = null;
            (!k(this.iconData.clickThroughUrl) || this.iconData.viewTrackings.length > 0) && (t = k(this.iconData.clickThroughUrl) ? new I(null, null, this.iconData.viewTrackings) : new I(this.iconData.clickThroughUrl, this.iconData.clickTrackings, this.iconData.viewTrackings));
            let e = new Y(this.iconData.properties, this.iconData.resources, t, this.iconData.clickFallbackImages, this.broker);
            e.isValid() ? this.creativeData.icons.push(e) : p.w("Discarding invalid Icon"), this.iconData.clear()
        }

        handleEndIFrameResource() {
            let t = this.characters.trim();
            this.iconData.properties.length > 0 ? this.iconData.resources.push(new E(A.IFRAME, t)) : this.creativeData.nonLinearResources.push(new E(A.IFRAME, t))
        }

        handleEndExtensionElement(t) {
            this.processingAdvertExtensions ? this.handleAdvertExtensionsForOnEndDefault(t) : this.handleCreativeExtensionsForOnEndDefault(t)
        }

        handleEndHtmlResource() {
            if (this.iconData.properties.length > 0) {
                let t = this.characters.trim();
                this.iconData.resources.push(new E(A.HTML, t, null, this.iconData.htmlResourceEncoded))
            } else this.creativeData.nonLinearResources.push(new E(A.HTML, this.characters, null, this.creativeData.htmlResourceEncoded))
        }

        handleEndIconClickFallbackImage() {
            let t = new W(this.iconClickFallbackImageData.properties, this.iconClickFallbackImageData.altText, this.iconClickFallbackImageData.resource);
            t.isValid() ? this.iconData.clickFallbackImages.push(t) : p.w("Discarding invalid IconClickFallbackImage"), this.iconClickFallbackImageData.clear()
        }

        handleEndIconClickTracking() {
            let t = this.characters.trim();
            z(t) ? this.iconData.clickTrackings.push(t) : p.w("Discarding empty Icon click tracking URL")
        }

        handleEndIconViewTracking() {
            let t = this.characters.trim();
            z(t) ? this.iconData.viewTrackings.push(t) : p.w("Discarding empty Icon view tracking URL")
        }

        handleEndInteractiveTracking() {
            this.creativeData.interactiveTracking ? this.creativeData.interactiveTracking.addTrackingUrl(this.characters.trim()) : this.creativeData.interactiveTracking = new D(this.creativeData.trackingEvent, [this.characters.trim()])
        }

        handleEndLinear() {
            let t = null;
            (!k(this.creativeData.clickThroughUrl) || this.creativeData.clickThroughCustoms.length > 0) && (t = k(this.creativeData.clickThroughUrl) ? new I(null, null, this.creativeData.clickThroughCustoms) : new I(this.creativeData.clickThroughUrl, this.creativeData.clickThroughTrackings, this.creativeData.clickThroughCustoms));
            let e = null;
            this.creativeData.properties.length > 0 && (e = new X(this.creativeData.icSource, this.creativeData.properties, this.broker, this.creativeData.interactiveTracking), e.isValid() || (p.w("Discarding invalid InteractiveCreative"), e = null));
            let i = new K(this.creativeData, t, e, this.broker);
            i.isValid() ? this.advertData.linearCreative = i : p.w("Discarding invalid LinearCreative"), this.creativeData.clear()
        }

        handleEndImpression(t) {
            let e = this.characters.trim();
            z(e) ? this.advertData.impressions ? this.advertData.impressions.addTrackingUrl(e) : this.advertData.impressions = new D(t, [e]) : p.w("Discarding empty Impression")
        }

        handleEndInteractiveCreativeFile() {
            this.creativeData.icSource = this.characters.trim()
        }

        handleEndJavaScriptResource() {
            if (this.advertData.verificationApiFramework && this.advertData.verificationBrowserOptional) {
                let t = new N("JavaScriptResource", this.characters.trim(), "apiFramework", this.advertData.verificationApiFramework);
                t.addAttribute("browserOptional", this.advertData.verificationBrowserOptional), this.advertData.verificationResources.push(t)
            }
            this.advertData.verificationApiFramework = null, this.advertData.verificationBrowserOptional = null
        }

        handleEndMediaFile() {
            0 !== this.creativeData.properties.length ? this.creativeData.icSource = this.characters.trim() : this.creativeData.currentAssetUri = this.characters.trim()
        }

        handleEndNonLinearClickTracking() {
            let t = this.characters.trim();
            z(t) ? this.creativeData.clickThroughTrackings.push(t) : p.w("Discarding empty Nonlinear click tracking URL")
        }

        handleEndPricing() {
            let t = this.characters.trim();
            if ("" !== t) {
                let e = new N("Pricing", t, "currency", this.advertData.pricingCurrency);
                e.addAttribute("model", this.advertData.pricingModel), k(this.advertData.pricingCurrency) || k(this.advertData.pricingModel) ? p.w("Discarding invalid Pricing property") : this.advertData.properties.push(e)
            } else p.w("Discarding invalid Pricing property")
        }

        handleEndUniversalAdId() {
            let t = this.characters.trim();
            "" !== t ? this.creativeData.universalAdIds.push(new N("UniversalAdId", t, "idRegistry", this.creativeData.universalAdIdRegistry)) : p.w("Discarding empty UniversalAdId URL")
        }

        handleEndVerification() {
            let t = new j(this.advertData);
            t.isValid() ? this.advertData.adVerifications.push(t) : p.w("Discarding invalid AdVerification"), this.advertData.verificationEvents = new Map, this.advertData.verificationResources = [], this.advertData.verificationParameters = null
        }

        handleEndVmapTracking() {
            let t = this.characters.trim();
            if (D.isValidAdBreakEvent(this.adBreakData.trackingEvent)) if (k(t)) p.w("Discarding empty VMAP"); else {
                let e = this.adBreakData.timelineTrackingMap.get(this.adBreakData.trackingEvent);
                e ? e.addTrackingUrl(t) : (e = new D(this.adBreakData.trackingEvent, [t]), this.adBreakData.timelineTrackingMap.set(this.adBreakData.trackingEvent, e))
            } else p.d(c, "Discarding invalid vmap:Tracking event")
        }

        handleEndNonLinear() {
            let t = null;
            this.creativeData.clickThroughUrl && "" !== this.creativeData.clickThroughUrl && (t = new I(this.creativeData.clickThroughUrl, this.creativeData.clickThroughTrackings, null));
            let e = new G(this.creativeData, t, this.creativeData.nonLinearResources, this.broker);
            e.isValid() ? (e.setNonLinear(this.advertData.nonLinear), this.nonLinearAdsData.nonLinearCreatives.push(e)) : p.w("Discarding invalid NonLinear"), this.creativeData.clear()
        }

        handleEndStaticResource() {
            let t = this.characters.trim();
            if (this.iconClickFallbackImageData.properties.length > 0) {
                let e = new E(A.STATIC, t, this.iconClickFallbackImageData.staticResourceCreativeType);
                if (e.isValid()) return void (this.iconClickFallbackImageData.resource = e)
            } else if (this.iconData.properties.length > 0) {
                let e = new E(A.STATIC, t, this.iconData.staticResourceCreativeType);
                if (e.isValid()) return void this.iconData.resources.push(e)
            } else {
                let e = new E(A.STATIC, t, this.creativeData.staticResourceCreativeType);
                if (e.isValid()) return void this.creativeData.nonLinearResources.push(e)
            }
            p.w("Discarding invalid StaticResource")
        }

        handleEndTracking() {
            if (k(z(this.characters.trim()))) p.w("Discarding empty tracking URL"); else {
                let t = null;
                D.isValidVerificationEvent(this.creativeData.trackingEvent) ? t = this.advertData.verificationEvents : this.advertData.currentCreativeType === bt && D.isValidLinearEvent(this.creativeData.trackingEvent) || 0 === this.creativeData.trackingEvent.indexOf("progress") ? t = this.creativeData.trackingMap : this.advertData.currentCreativeType === bt && D.isValidInteractiveEvent(this.creativeData.trackingEvent) ? this.handleEndInteractiveTracking() : this.advertData.currentCreativeType === Et && D.isValidCompanionEvent(this.creativeData.trackingEvent) ? t = this.creativeData.trackingMap : this.advertData.currentCreativeType === wt && D.isValidNonLinearEvent(this.creativeData.trackingEvent) && (t = this.nonLinearAdsData.trackingMap), t && this.parseMapForOnEndTracking(t)
            }
        }

        handleEndViewableImpression(t) {
            let e = this.characters.trim();
            if (k(z(e))) p.w("Discarding empty ViewableImpression URL"); else {
                let i = this.advertData.viewableImpressions.get(t);
                i ? i.addTrackingUrl(e) : (i = new D(t, [e]), this.advertData.viewableImpressions.set(t, i))
            }
        }

        handleTextDataForExtensions() {
            let t = this.characters.trim();
            if ("" !== t) {
                let e = [];
                if (e = this.processingAdvertExtensions ? this.advertData.extensionStack : this.advertData.currentCreativeType === Et ? this.creativeData.companionExtensionStack : this.creativeData.extensionStack, e.length > 0) {
                    e[e.length - 1].setInnerText(t)
                }
            }
        }

        handleVmapAdBreak() {
            if (null !== this.adBreakData.earlyReturn) return this.streamData.earlyReturn = this.adBreakData.earlyReturn, void this.adBreakData.clear();
            let t = new J(this.adBreakData.start, this.adBreakData.duration, this.adBreakData.position, this.adBreakData.timelineTrackingMap, this.adBreakData.breakType, this.adBreakData.identifier, null);
            if (this.adBreakData.adverts.length > 0 && t.setAdverts(this.adBreakData.adverts), t.postParse(this.broker), t.isValid()) {
                switch (J.getBreakTypeFromString(this.adBreakData.breakType)) {
                    case $.LINEAR:
                        this.linearAdBreaks.push(t);
                        break;
                    case $.NONLINEAR:
                        this.nonLinearAdBreaks.push(t);
                        break;
                    case $.DISPLAY:
                        this.displayAdBreaks.push(t)
                }
            } else p.w("Discarding empty ad break");
            this.adBreakData.clear()
        }

        handleYospaceAdBreak(t, e) {
            let i = e.duration;
            i && (this.adBreakData.duration = B(i));
            let r = e.position;
            r && (this.adBreakData.position = r);
            let n = e.earlyReturn;
            if (n) {
                let t = B(n, -1);
                this.adBreakData.earlyReturn = -1 !== t ? t + this.adBreakData.start : -1
            }
        }

        handleYospaceStream(t, e) {
            let i = e.urlDomain;
            i && (this.streamData.hostNode = i);
            let r = e.urlSuffix;
            if (r && (this.streamData.hostSuffix = r), e.duration) {
                let t = B(e.duration);
                t && (this.streamData.duration = t)
            }
            if (this.streamData.hostSuffix) {
                let t = this.streamData.hostSuffix.match("yo.p.si=([^&]+)");
                t && (this.streamData.sessionIdentifier = t[1])
            }
            let n = e.pdtinitial ? e.pdtinitial : null, s = e.pdtstart ? e.pdtstart : null,
                a = e.pdtend ? e.pdtend : null;
            k(n) || (this.streamData.pdtInitial = M(n, null)), this.streamData.pdtStart = M(s, null), this.streamData.pdtEnd = M(a, null), (null === this.streamData.pdtStart || null === this.streamData.pdtEnd || this.streamData.pdtStart > this.streamData.pdtEnd) && (this.streamData.pdtStart = null, this.streamData.pdtEnd = null, this.streamData.pdtInitial = null)
        }

        onCdata(t) {
            this.characters = t, (this.processingAdvertExtensions || this.processingCreativeExtensions) && this.handleTextDataForExtensions()
        }

        onOpenTag(t) {
            let e = t.attributes;
            if (this.processingAdvertExtensions || this.processingCreativeExtensions) this.handleStartExtensionElement(t, e); else {
                if ("vmap:VMAP" === t.name && (this.isVmap = !0), "yospace:Stream" === t.name && this.handleYospaceStream(t, e), "vmap:AdBreak" === t.name) {
                    let t = e.timeOffset;
                    t && (this.adBreakData.start = B(t));
                    let i = e.breakType;
                    i && (this.adBreakData.breakType = i);
                    let r = e.breakId;
                    r && (this.adBreakData.identifier = r)
                }
                if ("yospace:AdBreak" === t.name && this.handleYospaceAdBreak(t, e), "vmap:Tracking" === t.name && (this.adBreakData.trackingEvent = e.event), "VAST" === t.name) {
                    let t = e.version;
                    this.checkValidVersion(t) || (p.e("Invalid or missing VAST version; is AV tag defined?"), this.isValidVAST = !1)
                }
                "Ad" === t.name && this.handleStartAd(t, e), "AdWrapper" === t.name && this.handleStartAdWrapper(t, e), "Category" === t.name && (this.advertData.categoryAuthority = e.authority), "AdSystem" === t.name && (this.advertData.adSystemVersion = e.version), "Advertiser" === t.name && (this.advertData.advertiserId = e.id), "Survey" === t.name && (this.advertData.surveyType = e.type), "Pricing" === t.name && this.handleStartPricing(t, e), "UniversalAdId" === t.name && (this.creativeData.universalAdIdRegistry = e.idRegistry), "Extensions" === t.name && this.advertData.extensionStack.push(new S(t.name, Tt(e))), "Creative" === t.name && this.handleStartCreative(t, e), "Linear" === t.name && (this.advertData.currentCreativeType = bt, this.creativeData.skipOffset = e.skipoffset), "Icon" === t.name && this.populateIconPropertyList(e), "IconClickFallbackImage" === t.name && this.populateIconClickFallbackImagePropertyList(e), "AdParameters" === t.name && (this.creativeData.adParameters = new N("AdParameters", null, "xmlEncoded", e.xmlEncoded)), "InteractiveCreativeFile" === t.name && this.populateInteractiveCreativePropertyList(e), "NonLinearAds" === t.name && (this.advertData.currentCreativeType = wt), "NonLinear" === t.name && this.populateNonLinearPropertyList(e), "CompanionAds" === t.name && (this.advertData.currentCreativeType = Et, this.companionAdsData.required = e.required), "Companion" === t.name && this.populateCompanionPropertyList(e), "StaticResource" === t.name && this.handleStartStaticResource(e), "HTMLResource" === t.name && this.handleStartHtmlResource(e), "Tracking" === t.name && this.handleStartTracking(e), "Verification" === t.name && (this.advertData.verificationVendor = e.vendor), "JavaScriptResource" === t.name && (this.advertData.verificationApiFramework = e.apiFramework, this.advertData.verificationBrowserOptional = e.browserOptional), "ExecutableResource" === t.name && (this.advertData.verificationApiFramework = e.apiFramework, this.advertData.verificationResourceType = e.type), "Extension" === t.name && this.handleStartExtension(t, e), "CreativeExtensions" === t.name && this.addToCreativeExtensionStack(new S(t.name, Tt(e))), "CreativeExtension" === t.name && this.handleStartCreativeExtension(t, e), t.isSelfClosing && this.onCloseTag(t)
            }
        }

        onCloseTag(t) {
            if (this.processingAdvertExtensions || this.processingCreativeExtensions) return this.handleEndExtensionElement(t), void (this.characters = "");
            "vmap:AdBreak" === t && this.handleVmapAdBreak(), "vmap:Tracking" === t && this.handleEndVmapTracking(), "Ad" === t && this.handleEndAd(), "AdSystem" === t && this.advertData.properties.push(new N("AdSystem", this.characters.trim(), "version", this.advertData.adSystemVersion)), "AdTitle" === t && this.handleEndAdTitle(), "Impression" === t && this.handleEndImpression(t), "AdServingId" === t && this.advertData.properties.push(new N("AdServingId", this.characters.trim())), "Category" === t && this.advertData.properties.push(new N("Category", this.characters.trim(), "authority", this.advertData.categoryAuthority)), "Description" === t && this.advertData.properties.push(new N("Description", this.characters.trim())), "Advertiser" === t && this.advertData.properties.push(new N("Advertiser", this.characters.trim(), "id", this.advertData.advertiserId)), "Survey" === t && this.advertData.properties.push(new N("Survey", this.characters.trim(), "type", this.advertData.surveyType)), "Error" === t && this.handleEndError(t), "Pricing" === t && this.handleEndPricing(), "UniversalAdId" === t && this.handleEndUniversalAdId(), "Extensions" === t && this.pop(!0, !1), "CreativeExtensions" === t && this.pop(!1, !1), "Verification" === t && this.handleEndVerification(), "VerificationParameters" === t && (this.advertData.verificationParameters = this.characters.trim()), "MediaFile" === t && this.handleEndMediaFile(), "InteractiveCreativeFile" === t && this.handleEndInteractiveCreativeFile(), "ClickThrough" !== t && "NonLinearClickThrough" !== t && "CompanionClickThrough" !== t || (this.creativeData.clickThroughUrl = this.characters.trim()), "IconClickThrough" === t && (this.iconData.clickThroughUrl = this.characters.trim()), "ClickTracking" === t && this.handleEndClickTracking(), "NonLinearClickTracking" === t && this.handleEndNonLinearClickTracking(), "CompanionClickTracking" === t && this.handleEndCompanionClickTracking(), "IconClickTracking" === t && this.handleEndIconClickTracking(), "IconClickFallbackImage" === t && this.handleEndIconClickFallbackImage(), "AltText" === t && (this.iconClickFallbackImageData.properties.length > 0 ? this.iconClickFallbackImageData.altText = this.characters.trim() : this.creativeData.altText = this.characters.trim()), "CustomClick" === t && this.handleEndCustomClick(), "IconViewTracking" === t && this.handleEndIconViewTracking(), "Creative" === t && this.handleEndCreative(), "Linear" === t && this.handleEndLinear(), "NonLinearAds" === t && (this.advertData.nonLinearAds = new x(this.nonLinearAdsData.trackingMap, this.nonLinearAdsData.nonLinearCreatives), this.nonLinearAdsData.clear()), "NonLinear" === t && this.handleEndNonLinear(), "CompanionAds" === t && (this.advertData.companionAds = new b(this.companionAdsData.required, this.companionAdsData.companions), this.companionAdsData.clear()), "Companion" === t && this.handleEndCompanion(), "Icon" === t && this.handleEndIcon(), "AdParameters" === t && this.creativeData.adParameters.setValue(this.characters.trim()), "Duration" === t && (this.creativeData.duration = this.characters.trim()), "Viewable" !== t && "NotViewable" !== t && "ViewUndetermined" !== t || this.handleEndViewableImpression(t), "StaticResource" === t && this.handleEndStaticResource(), "HTMLResource" === t && this.handleEndHtmlResource(), "IFrameResource" === t && this.handleEndIFrameResource(), "Tracking" === t && this.handleEndTracking(), "JavaScriptResource" === t && this.handleEndJavaScriptResource(), "ExecutableResource" === t && this.handleEndExecutableResource()
        }

        onText(t) {
            this.characters = t, (this.processingAdvertExtensions || this.processingCreativeExtensions) && this.handleTextDataForExtensions()
        }

        static parse(t, e) {
            return new _t(e).parse(t)
        }

        parse(t) {
            return new Promise((e, i) => {
                try {
                    const i = yt.a.parser(!0);
                    i.onerror = t => {
                        p.e("Failed to parse document: " + t), e(null)
                    }, i.ontext = this.onText, i.onopentag = this.onOpenTag, i.onclosetag = this.onCloseTag, i.oncdata = this.onCdata, i.write(t).close();
                    let r = null;
                    this.isVmap ? this.isValidVAST || (p.e("Failed to parse document.  VAST not valid"), e(null)) : (p.e("Failed to parse document.  VMAP not found"), e(null)), function (t) {
                        if (p.debugflags & c) {
                            p.d(c, "\n--------------- VMAP PARSING SUMMARY ---------------"), p.d(c, " * Number of ad breaks: " + t.linearAdBreaks.length), p.d(c, " * Number of nonlinear ad breaks: " + t.nonLinearAdBreaks.length), p.d(c, " * Number of display ad breaks: " + t.displayAdBreaks.length), p.d(c, " * Stream duration: " + t.streamData.duration + "ms\n");
                            for (let e of t.linearAdBreaks) {
                                p.d(c, e.toString());
                                for (let t of e.getAdverts()) p.d(c, t.toString())
                            }
                            for (let e of t.nonLinearAdBreaks) {
                                p.d(c, e.toString());
                                for (let t of e.getAdverts()) p.d(c, t.toString())
                            }
                            for (let e of t.displayAdBreaks) {
                                p.d(c, e.toString());
                                for (let t of e.getAdverts()) p.d(c, t.toString())
                            }
                            p.d(c, "Early return:" + t.earlyReturn), p.d(c, "--------------- END PARSING SUMMARY ----------------\n")
                        }
                    }(this), r = new kt(this, t.toString()), r.sessionIdentifier = this.streamData.sessionIdentifier, r.streamDuration = this.streamData.duration, r.hostNode = this.streamData.hostNode, r.hostSuffix = this.streamData.hostSuffix, r.pdtStart = this.streamData.pdtStart, r.pdtEnd = this.streamData.pdtEnd, r.earlyReturn = this.streamData.earlyReturn, e(r)
                } catch (t) {
                    i(t)
                }
            })
        }

        parseMapForOnEndTracking(t) {
            let e = this.characters.trim(), i = t.get(this.creativeData.trackingEvent);
            i ? i.addTrackingUrl(e) : (i = -1 !== this.creativeData.trackingEvent.indexOf("progress") ? new D("progress", [e]) : new D(this.creativeData.trackingEvent, [e]), t.set(this.creativeData.trackingEvent, i))
        }

        pop(t, e) {
            let i = [];
            i = t ? this.advertData.extensionStack : this.advertData.currentCreativeType === Et ? this.creativeData.companionExtensionStack : this.creativeData.extensionStack;
            let r = i.pop();
            e ? i[i.length - 1].addChild(r) : t ? this.advertData.extensions = r : this.advertData.currentCreativeType === Et ? this.creativeData.companionExtensions = r : this.creativeData.extensions = r
        }

        populateCompanionProperty(t, e) {
            this.populateCreativeProperty(t, e)
        }

        populateCompanionPropertyList(t) {
            this.populateCompanionProperty(t, "id"), this.populateCompanionProperty(t, "width"), this.populateCompanionProperty(t, "height"), this.populateCompanionProperty(t, "assetWidth"), this.populateCompanionProperty(t, "assetHeight"), this.populateCompanionProperty(t, "expandedWidth"), this.populateCompanionProperty(t, "expandedHeight"), this.populateCompanionProperty(t, "apiFramework"), this.populateCompanionProperty(t, "adSlotId"), this.populateCompanionProperty(t, "pxratio"), this.populateCompanionProperty(t, "renderingMode")
        }

        populateCreativeProperty(t, e) {
            let i = t[e];
            k(i) || this.creativeData.properties.push(new N(e, i))
        }

        populateIconProperty(t, e) {
            let i = t[e];
            k(i) || this.iconData.properties.push(new N(e, i))
        }

        populateIconPropertyList(t) {
            this.populateIconProperty(t, "width"), this.populateIconProperty(t, "height"), this.populateIconProperty(t, "program"), this.populateIconProperty(t, "xPosition"), this.populateIconProperty(t, "yPosition"), this.populateIconProperty(t, "offset"), this.populateIconProperty(t, "duration"), this.populateIconProperty(t, "apiFramework"), this.populateIconProperty(t, "pxratio")
        }

        populateIconClickFallbackImageProperty(t, e) {
            let i = t[e];
            k(i) || this.iconClickFallbackImageData.properties.push(new N(e, i))
        }

        populateIconClickFallbackImagePropertyList(t) {
            this.populateIconClickFallbackImageProperty(t, "width"), this.populateIconClickFallbackImageProperty(t, "height")
        }

        populateInteractiveCreativeProperty(t, e) {
            this.populateCreativeProperty(t, e)
        }

        populateInteractiveCreativePropertyList(t) {
            this.populateInteractiveCreativeProperty(t, "apiFramework"), this.populateInteractiveCreativeProperty(t, "type"), k(t.variableDuration) ? this.creativeData.properties.push(new N("variableDuration", "false")) : this.populateInteractiveCreativeProperty(t, "variableDuration")
        }

        populateNonLinearProperty(t, e) {
            this.populateCreativeProperty(t, e)
        }

        populateNonLinearPropertyList(t) {
            this.populateNonLinearProperty(t, "id"), this.populateNonLinearProperty(t, "width"), this.populateNonLinearProperty(t, "height"), this.populateNonLinearProperty(t, "expandedWidth"), this.populateNonLinearProperty(t, "expandedHeight"), this.populateNonLinearProperty(t, "scalable"), this.populateNonLinearProperty(t, "maintainAspectRatio"), this.populateNonLinearProperty(t, "apiFramework"), this.populateNonLinearProperty(t, "minSuggestedDuration")
        }
    }

    class Mt {
        constructor(t, e, i) {
            this.url = t, this.opts = e, this.requestTimeout = i || r.e.REQUEST_TIMEOUT
        }

        static get(t, e, i, r) {
            if (k(t)) return void p.e("URL is missing");
            if (r) {
                let t = new Headers;
                for (let [e, i] of r) t.set(e, i);
                e.headers = t
            }
            return new Mt(t, e, i).executeGet()
        }

        executeGet() {
            return function (t, e, i) {
                let r = null;
                const n = new Promise(t => {
                    r = setTimeout(t, i, {timeout: !0})
                });
                return Promise.race([fetch(t, e), n]).then(e => (e.timeout ? p.d(h, "Request for " + t + " timed out") : e.ok || p.d(h, "Request for " + t + " failed. Status: " + e.status + ". Message: " + e.statusText), e)).catch(e => (p.d(h, "Request for " + t + " failed. Exception: " + e), {error: e})).finally(() => {
                    clearTimeout(r)
                })
            }(this.url, this.opts, this.requestTimeout)
        }
    }

    class Bt {
        constructor(t, e, i) {
            this.pollingUrl = t, this.isRequester = e, this.onRequest = i, this.irregularFuture = null
        }

        static setIgnoreNextPoll(t) {
            Bt.ignoreNextPoll = t
        }

        cancelAllPolls() {
            null !== this.irregularFuture && (clearTimeout(this.irregularFuture), this.irregularFuture = null)
        }

        execute(t) {
            if (this.irregularFuture = null, t) this.setIgnoreNextPoll(!0); else if (Bt.ignoreNextPoll) return this.setIgnoreNextPoll(!1), p.d(a, "Poll ignored for URL: " + this.pollingUrl), void (this.onRequest && this.onRequest(null));
            p.d(a, "Poll commencing for URL: " + this.pollingUrl);
            Mt.get(this.pollingUrl, {}, r.e.REQUEST_TIMEOUT).then(t => {
                t.ok && !t.error || p.w("Failed to read location [" + this.pollingUrl + "]"), this.onRequest && this.onRequest(t)
            })
        }

        poll() {
            this.execute(this.isRequester)
        }

        pollDelayed(t) {
            this.isRequester ? p.w("Requesters cannot schedule a poll") : this.irregularFuture ? p.w("Poll already scheduled.  Request ignored") : this.irregularFuture = setTimeout(this.execute.bind(this), t)
        }

        setIgnoreNextPoll(t) {
            Bt.ignoreNextPoll = t
        }

        shutdown() {
            this.cancelAllPolls(), p.d(s, "Poller shutdown")
        }
    }

    Bt.ignoreNextPoll = !1;

    class Ut {
        constructor(t, e, i, n) {
            this.retry = r.e.DEFAULT_POLLING_DELAY, this.broker = e, this.onPayload = i, this.onTimeout = n, this.initialiseUrlPoller(t), this.running = !1, this.lastPollStart = 0
        }

        getNextRetry(t) {
            let e = t - this.lastPollStart;
            return e < 0 ? this.lastPollStart - t : this.retry - e + this.retry * (e / this.retry)
        }

        getRetry() {
            return this.retry
        }

        initialiseUrlPoller(t) {
            p.d(s, "Analytic Poller initialising with url: " + t);
            this.urlPoller = new Bt(t, !1, t => {
                this.onHttpResponse(t, !1)
            }), this.urlRequester = new Bt(t, !0, t => {
                this.onHttpResponse(t, !0)
            })
        }

        isRunning() {
            return this.running
        }

        checkHttpResonse(t, e) {
            if (t && (p.trace("sdk poll"), p.d(a, "XML content returned at: " + Date.now() / 1e3)), this.running && !e) {
                if (!t) {
                    let t = this.pollDelayed();
                    return p.d(a, "Analytic Poll ignored.  Poll again in: " + t + " millis at " + this.lastPollStart), !1
                }
                if (!t.ok) {
                    if (400 === t.status) this.onTimeout && this.onTimeout(); else {
                        let t = this.pollDelayed();
                        p.d(a, "Analytic poll  failed.  Poll again in: " + t + " millis at " + this.lastPollStart)
                    }
                    return !0
                }
                this.scheduleNextPoll(t)
            }
            return !0
        }

        onHttpResponse(t, e) {
            if (this.checkHttpResonse(t, e)) {
                let i = "";
                t && t.ok && t.text().then(t => {
                    _t.parse(t, this.broker).then(t => {
                        if (this.running && !e) {
                            let t = this.pollDelayed();
                            i = "  Analytic Poller scheduled in: " + t + " millis at " + this.lastPollStart
                        }
                        t ? p.d(a, "Analytic Poll complete.  Data Received." + i) : p.d(a, "Analytic Poll complete.  No data." + i), this.onPayload && this.onPayload(t)
                    })
                }).catch(t => {
                    p.d(a, "Analytic Poll completed with unreadable data: " + t)
                })
            }
        }

        pollDelayed() {
            let t = Date.now(), e = this.getNextRetry(t);
            return this.urlPoller.pollDelayed(e), this.lastPollStart = t + e, e
        }

        request() {
            this.running && (this.urlRequester.poll(), p.d(s, "Analytic Poller requested"))
        }

        scheduleNextPoll(t) {
            let e = t.headers, i = e ? e.get("Retry-After") : null, r = parseInt(i);
            Number.isNaN(r) || (this.retry = 1e3 * r)
        }

        shutdown() {
            this.stop(), this.urlPoller.shutdown(), this.urlRequester.shutdown(), p.d(s, "Analytic Poller shutdown")
        }

        start() {
            this.running || (this.running = !0, this.urlPoller.poll(), this.lastPollStart = Date.now(), p.d(s, "Analytic Poller started"))
        }

        stop() {
            this.running && (this.urlPoller.cancelAllPolls(), this.running = !1, p.d(s, "Analytic Poller stopped"))
        }
    }

    const xt = 2 * r.e.MAX_CADENCE;

    class Ot extends ft {
        constructor(t) {
            super(t), this.didSeek = !1, this.duration = 0
        }

        getAdBreakForPlayhead(t) {
            for (let e of this.linearAdBreaks) if (e.getStart() <= t && t < e.getStart() + e.getDuration()) return e;
            return null
        }

        getDuration() {
            return this.duration
        }

        initialiseFromAnalyticData(t, e) {
            this.setPlaybackUrl(e + t.getHostNode() + t.getHostSuffix()), this.setDuration(t.getStreamDuration()), this.setIdentifier(t.getSessionIdentifier()), Array.prototype.push.apply(this.linearAdBreaks, t.getLinearAdBreaks()), Array.prototype.push.apply(this.nonLinearAdBreaks, t.getNonLinearAdBreaks()), Array.prototype.push.apply(this.displayAdBreaks, t.getDisplayAdBreaks())
        }

        onAdvertBreakStart(t) {
            if (!this.getCurrentAdBreak() && (this.setCurrentAdBreak(t), p.trace("adbreakStart"), this.getReportsManager().raiseAdBreakCallback("start", this.getCurrentAdBreak()), t && (t.isActive() || !t.isEnded()))) {
                let e = t.getTrackingReport("breakStart", !this.reportsManager.reportsSuppressed());
                this.getReportsManager().fireBeacon(e, new at(this.getPlayhead()))
            }
        }

        onAdvertBreakEnd() {
            let t = this.getCurrentAdBreak();
            if (t && (t.isActive() || !t.isEnded())) {
                let e = t.getTrackingReport("breakEnd", !0);
                this.getReportsManager().fireBeacon(e, new at(this.getPlayhead())), t.isActive() || (t.setInactive(), t.setEnded())
            }
            p.trace("adbreakEnd"), this.getReportsManager().raiseAdBreakCallback("end", null), this.setCurrentAdBreak(null)
        }

        onAdvertEnd() {
            let t = this.getCurrentAdvert();
            t && t.isActive() && this.signalTimelineTrackingEvents(t.getStart() + t.getDuration()), t && t.setInactive(), p.trace("advertEnd"), this.getReportsManager().raiseAdvertCallback("end", null), this.setCurrentAdvert(null)
        }

        onAdvertStart(t) {
            this.getCurrentAdvert() || (this.setCurrentAdvert(t), this.getReportsManager().reportsSuppressed() && t.removeTrackingSchedule(), p.trace("advertStart"), this.getReportsManager().raiseAdvertCallback("start", t), t && t.isActive() && (this.fireImpressionReport(), this.signalTimelineTrackingEvents(r.e.ADVERT_START_TIMESLOT)))
        }

        handlePostSeek(t) {
            let e = this.getLastPlayed();
            p.d(l, "handlePostSeek: " + e + " -> " + t);
            let i = t - e;
            i >= 0 && i <= xt ? p.d(l, "handlePostSeek: ignoring interval " + i + "ms") : this.getCurrentAdBreak() ? this.handlePostSeekForAdBreak(e, t) : this.handlePostSeekForContent(t)
        }

        handlePostSeekForContent(t) {
            let e = this.adBreakForPlayhead(t);
            if (e) {
                p.d(l, "handlePostSeek: CONTENT -> BREAK");
                let i = e.getAdvertFromPlayhead(t);
                i && t - i.getStart() > xt && i.setInactive()
            } else p.d(l, "handlePostSeek: within content")
        }

        handlePostSeekForAdBreak(t, e) {
            let i = this.adBreakForPlayhead(e);
            if (i) if (i !== this.getCurrentAdBreak()) {
                p.d(l, "handlePostSeek: BREAK -> BREAK");
                let r = this.getCurrentAdBreak().getAdvertFromPlayhead(t);
                r && r.setInactive();
                let n = i.getAdvertFromPlayhead(e);
                n && e - n.getStart() > xt && n.setInactive()
            } else this.handlePostSeekForAdvertToAdvert(e); else {
                p.d(l, "handlePostSeek: BREAK -> CONTENT");
                let e = this.getCurrentAdBreak().getAdvertFromPlayhead(t);
                e && e.setInactive()
            }
        }

        handlePostSeekForAdvertToAdvert(t) {
            let e = this.getCurrentAdBreak().getAdvertFromPlayhead(t);
            e && (this.getCurrentAdvert().setInactive(), e !== this.getCurrentAdvert() ? (p.d(l, "handlePostSeek: ADVERT -> ADVERT"), t - e.getStart() > xt && e.setInactive()) : p.d(l, "handlePostSeek: with advert"))
        }

        handleHeartbeat(t) {
            p.d(l, "handleHeartbeat (playhead: " + t + ")"), this.didSeek && (this.handlePostSeek(t), this.didSeek = !1);
            let e = this.getLastPlayed();
            this.setPlayhead(t), this.getCurrentAdBreak() ? this.handleHeartbeatForAdbreak(t) : this.handleHeartbeatForContent(e, t)
        }

        handleHeartbeatForContent(t, e) {
            let i = this.missedOpportunityBreak(t, e);
            if (i) {
                let t = new at(this.getPlayhead());
                this.getReportsManager().fireBeacon(i.getTrackingReport("breakStart", !0), t), this.getReportsManager().fireBeacon(i.getTrackingReport("breakEnd", !0), t), -1 !== this.linearAdBreaks.indexOf(i) && this.linearAdBreaks.splice(this.linearAdBreaks.indexOf(i), 1)
            }
            let r = this.adBreakForPlayhead(e);
            r && (p.d(l, "CONTENT -> BREAK (playhead: " + e + ")"), this.onAdvertBreakStart(r), this.onAdvertStart(r.getAdvertFromPlayhead(e)))
        }

        handleHeartbeatForAdbreak(t) {
            let e = this.adBreakForPlayhead(t);
            e ? e !== this.getCurrentAdBreak() ? (p.d(l, "BREAK -> BREAK"), this.onAdvertEnd(), this.onAdvertBreakEnd(), this.onAdvertBreakStart(e), this.onAdvertStart(e.getAdvertFromPlayhead(t))) : this.handleHeartbeatForAdvertToAdvert(t) : (p.d(l, "BREAK -> CONTENT"), this.onAdvertEnd(), this.onAdvertBreakEnd())
        }

        handleHeartbeatForAdvertToAdvert(t) {
            let e = this.getCurrentAdBreak().getAdvertFromPlayhead(t);
            if (e) if (e !== this.getCurrentAdvert()) p.d(l, "ADVERT -> ADVERT"), this.onAdvertEnd(), this.onAdvertStart(e); else {
                let e = Math.max(t - this.getCurrentAdvert().getStart(), 0);
                this.signalTimelineTrackingEvents(e)
            }
        }

        adBreakForPlayhead(t) {
            for (let e of this.linearAdBreaks) if (e.getStart() <= t && t < e.getStart() + e.getDuration()) return e;
            return null
        }

        missedOpportunityBreak(t, e) {
            for (let i of this.linearAdBreaks) if (0 === i.getDuration()) {
                let r = i.getStart();
                if (t <= r && e >= r) return i
            }
            return null
        }

        removeAdBreak(t) {
            for (let e = 0; e < this.linearAdBreaks.length; ++e) {
                if (this.linearAdBreaks[e] === t) return void this.linearAdBreaks.splice(e, 1)
            }
        }

        setAdBreaksInactivePriorTo(t) {
            for (let e of this.linearAdBreaks) if (!e.setAdvertsInactivePriorTo(t)) break
        }
    }

    class Ft {
        constructor(t, e, i) {
            this.sessionIdentifier = t.get(r.k), this.location = t.get(r.l), this.scheme = t.get(r.p), this.hostNode = t.get(r.j), this.port = t.get(r.n), this.queryString = t.get(r.o), this.analyticUrl = t.get(r.i), this.pauseUrl = t.get(r.m), this.raw = i || "", this.interSegmentTimeout = e
        }

        getAnalyticUrl() {
            return this.analyticUrl
        }

        getIntersegmentTimeout() {
            return this.interSegmentTimeout
        }

        getLocation() {
            return this.location
        }

        getHostNode() {
            return this.hostNode
        }

        getScheme() {
            return this.scheme
        }

        getPauseUrl() {
            return this.pauseUrl
        }

        getPort() {
            return this.port
        }

        getQueryString() {
            return this.queryString
        }

        getRaw() {
            return this.raw
        }

        getSessionIdentifier() {
            return this.sessionIdentifier
        }
    }

    class Vt {
        constructor() {
            this.data = new Map, this.s = "", this.error = null, this.onError = this.onError.bind(this), this.onText = this.onText.bind(this), this.onOpenTag = this.onOpenTag.bind(this), this.onCloseTag = this.onCloseTag.bind(this), this.onCdata = this.onCdata.bind(this)
        }

        static parse(t) {
            if (!t || 0 === t.length) return p.e("Yospace DASH manifest is empty"), null;
            return (new Vt).parse(t)
        }

        parse(t) {
            const e = yt.a.parser(!0);
            return e.onerror = this.onError, e.ontext = this.onText, e.onopentag = this.onOpenTag, e.onclosetag = this.onCloseTag, e.oncdata = this.onCdata, e.write(t), this.error ? null : new Ft(this.data, 1600, t)
        }

        onCdata(t) {
            this.s += t
        }

        onError() {
            this.error = !0
        }

        onCloseTag(t) {
            if ("LOCATION" === t.toUpperCase()) {
                let t = this.s.trim();
                this.data.set(r.l, t);
                let e = t.split(/\?/);
                try {
                    let i = new URL(e[0]);
                    this.data.set(r.p, i.protocol.substring(0, i.protocol.length - 1)), this.data.set(r.j, i.hostname), this.data.set(r.n, i.port), this.data.set(r.o, 2 === e.length ? e[1] : null);
                    let n = e[0].match("/live/(\\d+)/.+?;jsessionid=([^?\\s]+)");
                    if (n) this.data.set(r.k, n[2]); else if (-1 !== t.indexOf("yo.js")) {
                        let e = t.match("yo.js=([^&]+)");
                        e && this.data.set(r.k, e[1])
                    }
                    void 0 === this.data.get(r.k) && (this.error = !0)
                } catch (t) {
                    p.e("Failed to parse Location element: " + t), this.error = !0
                }
            }
        }

        onOpenTag(t) {
            this.s = "", "MPD" === t.name.toUpperCase() && (this.data.set(r.i, t.attributes.analytics), this.data.set(r.m, t.attributes.livePause))
        }

        onText(t) {
            this.s = t
        }
    }

    const Ht = /;jsessionid=([^?]+)/, jt = /yo\.js=([^?]+)/;

    class qt {
        constructor() {
            this.data = new Map
        }

        buildPlaybackUrl() {
            let t = this.data.get(r.l);
            t && !z(t) && (p.w("Master URL invalid in HSL manifest: " + t), this.data.delete(r.l));
            let e = !1, i = this.data.get(r.l);
            i || (i = this.data.get("FIRSTLEVELPLAYLIST"));
            let n = z(i), s = i.match(jt), a = i.match(Ht);
            if (n && (s ? (e = !0, this.data.set(r.k, s[1])) : a && this.data.set(r.k, a[1])), !n || void 0 === this.data.get(r.k)) return p.e("Unable to build Location from components"), !1;
            let o = n.port;
            return this.data.set(r.n, "" === o ? "" : o), this.data.set(r.p, n.protocol.substring(0, n.protocol.length - 1)), this.data.set(r.j, n.hostname), this.data.set(r.o, n.search ? n.search.replace("?", "") : ""), this.updateLocationPath(n, e), !0
        }

        updateLocationPath(t, e) {
            if (void 0 === this.data.get(r.l)) {
                let i = t.pathname, n = i.substring(0, i.lastIndexOf("/")) + ".m3u8", s = this.data.get(r.p);
                s += "://", s += this.data.get(r.j), s += "" !== this.data.get(r.n) ? ":" + this.data.get(r.n) : "", s += n, e || (s += ";jsessionid=" + this.data.get(r.k)), k(this.data.get(r.o)) || (s += "?" + this.data.get(r.o)), this.data.set(r.l, s)
            }
        }

        static checkParameters(t, e) {
            return k(e) ? (p.e("Yospace HLS manifest is empty"), !1) : -1 === e.indexOf("#EXT-X-STREAM-INF:") ? (p.e("No stream info found in HLS manifest"), !1) : !!z(t) || (p.e("Playback Url is empty or invalid in HLS manifest"), !1)
        }

        checkAnalyticUrl() {
            let t = this.data.get(r.i);
            k(t) ? p.e("Unable to parse analytic URL in HLS manifest") : z(t) || p.e("Analytic URL invalid in HLS manifest: " + t)
        }

        checkPauseUrl() {
            let t = this.data.get(r.m);
            k(t) || z(t) || p.e("Pause URL invalid in HSL manifest: " + t)
        }

        static isHlsManifest(t) {
            return t.length >= 7 && -1 !== t.toUpperCase().indexOf("#EXTM3U")
        }

        parseManifestLines(t) {
            let e = t.split(/\r?\n/);
            for (let t of e) if (t.startsWith("#")) {
                let e = t.indexOf(":");
                if (-1 !== e) {
                    let i = t.substring(e + 1), n = t.substring(0, e);
                    n.includes("#EXT-X-YOSPACE-ANALYTICS-URL") ? this.data.set(r.i, i.replace(/"/g, "")) : n.includes("#EXT-X-YOSPACE-PAUSE") ? this.data.set(r.m, i.replace(/"/g, "")) : n.includes("#EXT-X-YOSPACE-SDK-MASTER-URL") && this.data.set(r.l, i.replace(/"/g, ""))
                }
            } else void 0 === this.data.get("FIRSTLEVELPLAYLIST") && this.data.set("FIRSTLEVELPLAYLIST", t)
        }

        static parse(t, e) {
            let i = new qt;
            return qt.checkParameters(t, e) && (i.parseManifestLines(e), i.checkAnalyticUrl(), i.checkPauseUrl(), i.buildPlaybackUrl()) ? new Ft(i.data, r.e.INTERSEGMENT_TIMEOUT, e) : null
        }
    }

    class Wt {
        constructor(t) {
            if (this.constructor !== Wt) throw new Error("Class should not be extended");
            this.running = !1, this.urlPoller = null, this.initialiseUrlPoller(t)
        }

        initialiseUrlPoller(t) {
            p.d(s, "Pause Poller initialising with url: " + t), this.urlPoller = new Bt(t, !1, t => {
                this.onHttpResponse(t)
            })
        }

        onHttpResponse(t) {
            if (this.running) {
                let e = r.e.DEFAULT_POLLING_DELAY;
                if (t && 400 === t.status) return;
                if (t && t.ok) {
                    let i = t.headers, r = i ? i.get("Retry-After") : null, n = parseInt(r);
                    Number.isNaN(n) || (e = 1e3 * n), p.d(a, "Pause poll again in: " + e + " millis")
                } else p.d(a, "Pause poll failed.  Poll again in: " + e + " ms");
                this.urlPoller.pollDelayed(e)
            }
        }

        shutdown() {
            this.stop(), this.urlPoller.shutdown(), p.d(s, "Pause poller shutdown")
        }

        start() {
            this.running || (this.running = !0, this.urlPoller.poll(), p.d(s, "Pause poller started"))
        }

        stop() {
            this.running && (this.urlPoller.cancelAllPolls(), this.running = !1, p.d(s, "Pause poller stopped"))
        }
    }

    class Yt extends Ot {
        constructor(t) {
            super(t), this.streamStart = -1, this.windowStart = -1, this.windowEnd = -1, this.windowSize = -1, this.analyticPoller = null, this.pausePoller = null, this.pauseUrl = "", this.initialPlayhead = -1, this.isFallbackLive = !1, this.fallbackPollRequested = !1
        }

        static create(t, e, i) {
            let r = new Yt(e);
            if (!i) return r.initialiseFromSession(t);
            r.initialiseFromSession(t).then(() => {
                p.d(s, "Session initialised")
            }).catch(() => {
                p.d(s, "Session failed to initialise")
            }).finally(() => {
                i(new V(r))
            })
        }

        initialiseFromSession(t) {
            return new Promise((e, i) => {
                p.trace("sdk init"), z(t) || (this.completeWithStatus(ht.FAILED, dt), i(this)), Mt.get(t, {method: "GET"}, this.sessionProperties.getRequestTimeout(), this.sessionProperties.getCustomHttpHeaders()).then(r => {
                    if (r.ok) {
                        let t = r.url;
                        r.text().then(r => {
                            let n = this.parseManifestResponse(r, t);
                            this.setPlaybackUrl(t), this.initialiseFromPayload(n), this.getSessionResult() !== ht.INITIALISED && this.getSessionResult() !== ht.NO_ANALYTICS && i(this), this.getSessionResult() === ht.INITIALISED && this.initialisePoller(), e(this)
                        })
                    } else r.timeout ? (p.e("Primary Url request failed: " + t + ", reason: timeout"), this.completeWithStatus(ht.FAILED, ut)) : (p.e("Primary Url request failed: " + t + ", status: " + r.status + ", error: " + r.statusText), this.completeWithStatus(ht.FAILED, r.status)), i(this)
                }).catch(e => {
                    p.e("Primary Url request failed: " + t + ", status: , reason: " + e), this.completeWithStatus(ht.FAILED, ct), i(this)
                })
            })
        }

        adjustForEarlyReturn(t) {
            let e = this.getAdBreakForPlayhead(t);
            e && e.adjustForEarlyReturn(t) && (this.getReportsManager().raiseAdBreakEarlyReturn(e), e.isValid() || this.linearAdBreaks.splice(this.linearAdBreaks.indexOf(e)))
        }

        getDuration() {
            return this.windowEnd
        }

        getPauseUrl() {
            return this.pauseUrl
        }

        getStreamStart() {
            return this.streamStart
        }

        getWindowStart() {
            return this.windowStart
        }

        getWindowEnd() {
            return this.windowEnd
        }

        getWindowSize() {
            return this.windowSize
        }

        removeExpiredAdBreaks() {
            let t = -1 === this.streamStart ? this.getPlayhead() : this.windowStart,
                e = this.getAdBreakForPlayhead(this.getPlayhead());
            for (let i = this.linearAdBreaks.length - 1; i >= 0; i--) {
                let r = this.linearAdBreaks[i];
                if (r.getStart() + r.getDuration() <= t) {
                    if (p.d(s, "Removing ad break.  Start: " + r.getStart() + "; duration: " + r.getDuration()), r === e) {
                        p.d(s, "Removing the current adbreak");
                        let t = e.getAdvertFromPlayhead(this.getPlayhead());
                        t && t.setInactive(), this.onAdvertEnd(), this.onAdvertBreakEnd()
                    }
                    this.linearAdBreaks.splice(i, 1)
                }
            }
        }

        shutdown() {
            super.shutdown(), this.analyticPoller && (this.analyticPoller.shutdown(), this.analyticPoller = null), this.pausePoller && (this.pausePoller.shutdown(), this.pausePoller = null), p.d(s, "resources released")
        }

        getPlaybackMode() {
            return lt.DVRLIVE
        }

        initialisePoller() {
            this.getAnalyticsUrl() && this.pauseUrl && this.getSessionResult() === ht.INITIALISED && (this.analyticPoller = new Ut(this.getAnalyticsUrl(), this, t => {
                this.onAnalyticPayloadReceived(t)
            }, this.onTimeout.bind(this)), this.pausePoller = new Wt(this.pauseUrl))
        }

        onAnalyticPayloadReceived(t) {
            if (!t) return;
            if (this.getLastAnalyticUpdate() && this.getLastAnalyticUpdate().isEqualTo(t)) return void p.d(c, "Content unchanged.  Analytic update not delivered");
            let e = t.getEarlyReturn();
            if (e && -1 !== e && this.adjustForEarlyReturn(e), -1 === this.streamStart) {
                let e = t.getPdtInitial();
                null !== e && (this.streamStart = e, this.isFallbackLive && (p.d(c, "Received pdtInitial; returning to DVRLive"), this.isFallbackLive = !1))
            }
            if (this.isFallbackLive && !t.hasAdBreaks()) p.d(c, "FallbackLive: No ad breaks in payload.  Discarding"); else {
                let e = !1;
                if (!this.isFallbackLive) {
                    let i = t.getPdtStart(), r = t.getPdtEnd();
                    if (null !== i && null !== r) {
                        let t = i, n = r;
                        -1 === this.streamStart && (this.streamStart = t);
                        let s = t - this.streamStart, a = n - this.streamStart;
                        s === this.windowStart && a === this.windowEnd || (e = !0, this.windowStart = s, this.windowEnd = a, this.windowSize = this.windowEnd - this.windowStart)
                    } else p.w("PDT start/end value(s) invalid or missing")
                }
                let i = t.getLinearAdBreaks(), r = t.getNonLinearAdBreaks(), n = t.getDisplayAdBreaks(), s = i.length,
                    a = r.length, o = n.length;
                Array.prototype.push.apply(this.linearAdBreaks, i), Array.prototype.push.apply(this.nonLinearAdBreaks, r), -1 === this.streamStart ? p.d(c, "Received " + s + " linear, " + a + " nonlinear " + o + " display ad breaks") : p.d(c, "Received: " + s + " linear, " + a + " nonlinear  " + o + " display ad breaks. New window start: " + this.windowStart + ", end: " + this.windowEnd + " (total: " + this.windowSize + ")"), this.removeExpiredAdBreaks(), (-1 !== this.streamStart && e || t.hasAdBreaks()) && (p.trace("sdk analytics " + s + " " + a + " " + o + " " + this.getDuration()), this.setLastAnalyticUpdate(t), this.getReportsManager().raiseAnalyticUpdateCallback())
            }
        }

        onTimeout() {
            this.setState(ht.TIMEOUT), this.pausePoller.stop(), this.analyticPoller.stop(), this.getReportsManager().raiseSessionTimeoutCallback()
        }

        updatePayload(t) {
            this.onAnalyticPayloadReceived(t)
        }

        setAdBreaksInactivePriorTo(t) {
            for (let e of this.linearAdBreaks) if (!e.setAdvertsInactivePriorTo(t)) break
        }

        setStreamStart(t) {
            this.streamStart = t
        }

        parseManifestResponse(t, e) {
            let i = t;
            return qt.isHlsManifest(i) ? (p.d(c, "Processing HLS master manifest: " + e), qt.parse(e, i)) : (p.d(c, "Processing DASH manifest: " + e), Vt.parse(i))
        }

        initialiseFromPayload(t) {
            t ? k(t.getAnalyticUrl()) ? (p.e("Analytics URL not found in manifest payload"), p.w("Playlist/manifest processing unsuccessful"), this.completeWithStatus(ht.NO_ANALYTICS, 0)) : z(t.getAnalyticUrl()) ? z(t.getLocation()) ? (this.setPlaybackUrl(t.getLocation()), k(t.getPauseUrl()) ? (p.e("Pause URL not found in manifest"), this.completeWithStatus(ht.NO_ANALYTICS, -11)) : z(t.getPauseUrl()) ? (this.setIdentifier(t.getSessionIdentifier()), this.setAnalyticsUrl(t.getAnalyticUrl()), this.pauseUrl = t.getPauseUrl(), this.completeWithStatus(ht.INITIALISED, 0), p.d(s, "Successful. Url: " + this.getPlaybackUrl())) : (p.e("Malformed pause URL in manifest"), this.completeWithStatus(ht.NO_ANALYTICS, -11))) : (p.e("Player URL is invalid: " + t.getLocation()), p.w("Playlist/manifest processing unsuccessful"), this.completeWithStatus(ht.NO_ANALYTICS, 0)) : (p.e("Malformed analytics URL in manifest"), p.w("Playlist/manifest processing unuccessful"), this.completeWithStatus(ht.NO_ANALYTICS, dt)) : (p.e("Unable to process master manifest"), this.completeWithStatus(ht.NO_ANALYTICS, pt))
        }

        onPlaybackStart(t) {
            this.isNotPlaying() ? this.getSessionResult() !== ht.INITIALISED ? p.w("Reporting START when session is not initialised") : this.analyticPoller && (this.initialPlayhead = t, super.onPlaybackStart(t), this.analyticPoller.start()) : p.w("Reporting START when start has already been reported")
        }

        onPlaybackPause() {
            this.isNotPlaying() || this.pausePoller && this.getSessionResult() === ht.INITIALISED && this.pausePoller.start(), super.onPlaybackPause()
        }

        onPlaybackResume() {
            this.isNotPlaying() && this.pausePoller && this.pausePoller.stop(), super.onPlaybackResume()
        }

        onPlayerEvent(t, e) {
            t !== tt.SEEK && t !== tt.ADVERT_SKIP && t !== tt.ADVERT_REWIND || (this.didSeek = !0), super.onPlayerEvent(t, e)
        }

        onPlayheadUpdate(t) {
            if (-1 === this.streamStart && !this.isFallbackLive && this.analyticPoller && this.analyticPoller.isRunning()) {
                let e = this.analyticPoller.getRetry();
                t >= this.initialPlayhead + e ? (p.w("Did not receive pdtStart/End within " + e + "ms; going into FallbackLive"), this.isFallbackLive = !0) : t >= this.initialPlayhead + e / 2 && (this.fallbackPollRequested || (p.w("Did not receive pdtStart/End after " + t + "ms; polling again"), this.fallbackPollRequested = !0, this.analyticPoller.request()))
            }
            this.handleHeartbeat(t), super.onPlayheadUpdate(t)
        }

        canPause() {
            return -1 !== this.streamStart && super.canPause()
        }

        canSkip() {
            return -1 === this.streamStart ? -1 : this.policyHandler ? this.policyHandler.canSkip(this.getPlayhead(), this.linearAdBreaks, this.getDuration()) : 0
        }

        willSeekTo(t) {
            return -1 === this.streamStart ? this.getPlayhead() : super.willSeekTo(t)
        }
    }

    class Gt {
        constructor(t, e, i, r, n, s) {
            this.mediaId = Gt.decodeString(t), this.offset = n, this.segmentCount = i, this.segmentNumber = e, this.playhead = s, this.timestamp = Date.now(), this.typeWithinSegment = r
        }

        static createFromMetadata(t, e, i, r, n) {
            if (!t) return p.e("Failed to interpret ymid"), null;
            i = Gt.decodeString(i);
            let s = zt.getForKey(i);
            if (null == s) return p.e("Failed to interpret ytyp"), null;
            let a = Gt.decodeString(e).split(":");
            if (2 !== a.length) return p.e("Failed to interpret yseq"), null;
            let o = parseInt(a[0]), l = parseInt(a[1]);
            if (isNaN(o) || 0 === o || isNaN(l) || 0 === l) return p.e("Failed to interpret yseq"), null;
            let h = parseFloat(this.decodeString(r)), c = Number.isNaN(h) ? 0 : Math.round(1e3 * h);
            return n < 0 ? (p.w("Invalid playhead provided:" + n), null) : new Gt(t, o, l, s, c, n)
        }

        static decodeString(t) {
            return t && t.length > 0 && 3 === t[0] ? t.substring(1) : t
        }

        getMediaId() {
            return this.mediaId
        }

        getOffset() {
            return this.offset
        }

        getPlayhead() {
            return this.playhead
        }

        getSegmentCount() {
            return this.segmentCount
        }

        getSegmentNumber() {
            return this.segmentNumber
        }

        getTimestamp() {
            return this.timestamp
        }

        getTypeWithinSegment() {
            return this.typeWithinSegment
        }

        isDuplicate(t) {
            return !!t && (this.mediaId === t.mediaId && this.segmentNumber === t.segmentNumber && this.segmentCount === t.segmentCount && this.typeWithinSegment === t.typeWithinSegment && this.offset === t.offset)
        }

        isFirstInSequence() {
            return this.isFirstInSegment() && 1 === this.segmentNumber
        }

        isFirstInSegment() {
            return this.typeWithinSegment === zt.START
        }

        isInSequence(t) {
            if (!t) return !0;
            if (this.mediaId !== t.mediaId) return this.isFirstInSequence();
            let e = this.segmentNumber - t.segmentNumber;
            return 0 === e ? this.typeWithinSegment.isInSequence(t.typeWithinSegment) || this.typeWithinSegment.isEqualMidType(t.typeWithinSegment) && this.offset > t.offset : e > 0
        }

        isLastInSegment() {
            return this.typeWithinSegment === zt.END
        }

        isLastInSequence() {
            return this.isLastInSegment() && this.isLastSegment()
        }

        isLastSegment() {
            return this.segmentNumber === this.segmentCount
        }

        toString() {
            return "Metadata [ @" + this.playhead + " / " + this.mediaId + " / " + this.segmentNumber + ":" + this.segmentCount + " / " + this.typeWithinSegment.key + " : " + this.offset + " ]"
        }
    }

    class zt {
        constructor(t, e) {
            this.key = t, this.order = e
        }

        static getForKey(t) {
            if (!zt.initialised) {
                let t = zt.END, e = zt.MID, i = zt.START;
                zt.KEY_MAP.set(t.key, t), zt.KEY_MAP.set(e.key, e), zt.KEY_MAP.set(i.key, i), zt.initialised = !0
            }
            return zt.KEY_MAP.get(t)
        }

        isEqualMidType(t) {
            return !!t && (1 === this.order && 1 === t.order)
        }

        isInSequence(t) {
            return !t || this.order > t.order
        }
    }

    zt.END = new zt("E", 2), zt.MID = new zt("M", 1), zt.START = new zt("S", 0), zt.KEY_MAP = new Map, zt.initialised = !1;
    const Xt = Object.freeze({PLAYED_OUT: 0, NOT_PLAYED_OUT: 1, NEW_ADVERT_STARTING: 2});

    class Kt extends ft {
        constructor(t, e, i) {
            super(t), this.advertEndWatchdog = null, this.interSegmentTimeout = r.e.INTERSEGMENT_TIMEOUT, this.lastTimedMetadata = null, this.pendingTimedMetadata = null, this.historicalTimedMetadata = [], this.inAdBreak = !1, this.targetDuration = r.e.DEFAULT_POLLING_DELAY, this.analyticPoller = null, this.setAnalyticsUrl(e), this.setPlaybackUrl(i)
        }

        static create(t, e, i) {
            let r = new Kt(e);
            if (!i) return r.initialiseFromSession(t);
            r.initialiseFromSession(t).then(() => {
                p.d(s, "Session initialised")
            }).catch(() => {
                p.d(s, "Session failed to initialise")
            }).finally(() => {
                i(new V(r))
            })
        }

        static handleCreateError(t, e, i, r) {
            0 !== i || 200 !== r || e ? (t.setResultCode(0 !== i ? i : r), p.e("Live proxy initialisation failed (" + t.getResultCode() + ")")) : (t.setState(ht.NO_ANALYTICS), t.setResultCode(ft.UNKNOWN_FORMAT), p.w("Playlist/manifest processing unsuccessful"))
        }

        cancelScheduleWatchdog() {
            null !== this.advertEndWatchdog && (clearTimeout(this.advertEndWatchdog), this.advertEndWatchdog = null, p.d(s, "Cancelled watchdog timer"))
        }

        canPause() {
            return !!this.policyHandler && this.policyHandler.canPause(this.getPlayhead(), this.linearAdBreaks)
        }

        canSkip() {
            return this.policyHandler ? this.policyHandler.canSkip(this.getPlayhead(), this.linearAdBreaks, 0) : -1
        }

        willSeekTo(t) {
            return this.policyHandler ? this.policyHandler.willSeekTo(t, this.linearAdBreaks, this.getPlayhead()) : this.getPlayhead()
        }

        getAdBreakForAdvert(t) {
            if (t && this.linearAdBreaks.length > 0) {
                let e = t.getMediaIdentifier();
                for (let t of this.linearAdBreaks) {
                    if (t.getAdvertFromIdentifier(e)) return t
                }
            }
            return null
        }

        getFirstAdvertRemovingAllPrevious(t) {
            if (0 === this.linearAdBreaks.length) return null;
            let e = null, i = -1;
            for (let r = 0; r < this.linearAdBreaks.length; ++r) {
                let n = this.linearAdBreaks[r];
                for (let s of n.getAdverts()) {
                    if (s.getMediaIdentifier() === t && s.isActive()) {
                        e = s, i = r;
                        break
                    }
                    s.setInactive()
                }
                if (null !== e) break
            }
            return i > 0 && this.linearAdBreaks.splice(0, i), e
        }

        getMetadataTimeout(t) {
            return t && t.getTypeWithinSegment() === zt.END ? this.interSegmentTimeout : Math.max(this.targetDuration + 1e3 >> 1, r.e.MIN_INTRASEGMENT_TIMEOUT)
        }

        getPlaybackMode() {
            return lt.LIVE
        }

        handleMetaDataInSequence(t, e) {
            let i = this.getCurrentAdvert();
            if (e.isFirstInSequence()) this.onAdvertStart(t, e.getPlayhead()); else if (e.isLastInSequence()) !i || i.isFiller() && !this.hasFillerExpired(this.getCurrentAdvert(), e) || this.onAdvertEnd(Xt.PLAYED_OUT); else if (i) if (e.isLastInSegment() && i.isFiller() && this.hasFillerExpired(this.getCurrentAdvert(), e)) p.d(l, "Filler expired.  Ending advert and ad break"), this.onAdvertEnd(Xt.PLAYED_OUT); else {
                let t = Math.max(e.getPlayhead() - i.getStart(), 0);
                this.signalTimelineTrackingEvents(t)
            } else this.onAdvertBreakStart(t)
        }

        handleMetaDataOutOfSequence(t, e) {
            let i = this.getCurrentAdvert();
            i ? i.getMediaIdentifier() !== t.getMediaIdentifier() && (this.onAdvertEnd(Xt.NOT_PLAYED_OUT), e.isFirstInSequence() ? this.onAdvertStart(t, e.getPlayhead()) : (e.isLastInSequence() || t.isFiller() && e.isLastInSegment() && this.hasFillerExpired(t, e)) && (t.setInactive(), this.getCurrentAdBreak().isActive() || this.onAdvertBreakEnd())) : e.isFirstInSequence() ? this.onAdvertStart(t, e.getPlayhead()) : this.scheduleAdvertBreakEnd(this.interSegmentTimeout)
        }

        hasFillerExpired(t, e) {
            return p.d(l, "(FILLER CHECK) Ad duration: " + t.getDuration() + ", current: " + e.getPlayhead() - t.getStart() + this.interSegmentTimeout), e.getPlayhead() - t.getStart() + this.interSegmentTimeout >= t.getDuration()
        }

        initialiseFromSession(t) {
            return new Promise((e, i) => {
                p.trace("sdk init"), z(t) || (this.completeWithStatus(ht.FAILED, dt), i(this)), Mt.get(t, {method: "GET"}, this.sessionProperties.getRequestTimeout(), this.sessionProperties.getCustomHttpHeaders()).then(r => {
                    if (r.ok) {
                        let i = r.url ? r.url : t;
                        r.text().then(t => {
                            this.parseManifestResponse(t, i), this.getSessionResult() === ht.INITIALISED && this.initialisePoller(), e(this)
                        })
                    } else r.timeout ? (p.e("Primary Url request failed: " + t + ", reason: timeout"), this.completeWithStatus(ht.FAILED, ut)) : (p.e("Primary Url request failed: " + t + ", status: " + r.status + ", error: " + r.statusText), this.completeWithStatus(ht.FAILED, r.status)), i(this)
                }).catch(e => {
                    p.e("Primary Url request failed: " + t + ", status: , reason: " + e), this.completeWithStatus(ht.FAILED, ct), i(this)
                })
            })
        }

        initialisePoller() {
            this.getAnalyticsUrl() && this.getSessionResult() === ht.INITIALISED && (this.analyticPoller = new Ut(this.getAnalyticsUrl(), this, t => {
                this.onAnalyticPayloadReceived(t)
            }, this.onTimeout.bind(this)))
        }

        isMetadataInSequence(t, e) {
            return this.pendingTimedMetadata ? (p.d(l, "Pending metadata"), !1) : e.isInSequence(t)
        }

        onAdvertBreakEnd() {
            if (!this.inAdBreak) return;
            let t = this.getCurrentAdBreak();
            if (t) {
                let e = t.getTrackingReport("breakEnd", !0);
                this.getReportsManager().fireBeacon(e, new at(this.getPlayhead()))
            }
            this.inAdBreak = !1, p.trace("adbreakEnd"), this.getReportsManager().raiseAdBreakCallback("end", null), this.linearAdBreaks.length > 0 && (this.linearAdBreaks.splice(0, 1), p.d(s, "Removed AdBreak.  Remaining: " + this.linearAdBreaks.length)), this.lastTimedMetadata = null, this.pendingTimedMetadata = null, this.historicalTimedMetadata = [], this.setCurrentAdvert(null), this.setCurrentAdBreak(null)
        }

        onAdvertBreakStart(t) {
            if (this.inAdBreak) return;
            this.inAdBreak = !0;
            let e = this.getAdBreakForAdvert(t);
            if (this.setCurrentAdBreak(e), p.d(s, "AdBreak count: " + this.linearAdBreaks.length), p.trace("adbreakStart"), this.getReportsManager().raiseAdBreakCallback("start", e), e) {
                let t = e.getTrackingReport("breakStart", !this.reportsManager.reportsSuppressed());
                this.getReportsManager().fireBeacon(t, new at(this.getPlayhead()))
            }
        }

        onAdvertEnd(t) {
            this.getCurrentAdvert() && (t !== Xt.NEW_ADVERT_STARTING ? this.cancelScheduleWatchdog() : p.d(l, "onAdvertEnd(): new ad starting, not firing adbreak watchdog timer"), t === Xt.PLAYED_OUT ? this.signalTimelineTrackingEvents(this.getCurrentAdvert().getDuration()) : this.getCurrentAdvert().clearTrackingSchedule(), this.getCurrentAdvert().setInactive(), p.trace("advertEnd"), this.getReportsManager().raiseAdvertCallback("end", null), this.setCurrentAdvert(null), this.getCurrentAdBreak().isActive() ? t !== Xt.NEW_ADVERT_STARTING && this.scheduleAdvertBreakEnd(this.interSegmentTimeout) : this.onAdvertBreakEnd())
        }

        onAdvertStart(t, e) {
            t.setStart(e), this.onAdvertEnd(Xt.NEW_ADVERT_STARTING), this.onAdvertBreakStart(t), this.setCurrentAdBreak(this.getAdBreakForAdvert(t)), this.getCurrentAdBreak() ? (this.setCurrentAdvert(t), t.isFiller() && p.d(l, "Filler advert, duration: " + t.getDuration()), this.reportsManager.reportsSuppressed() && this.getCurrentAdvert().clearTrackingSchedule(), p.trace("advertStart"), this.getReportsManager().raiseAdvertCallback("start", t), this.fireImpressionReport(), this.signalTimelineTrackingEvents(r.e.ADVERT_START_TIMESLOT)) : p.e("*** AdBreak is null ***")
        }

        onAnalyticPayloadReceived(t) {
            if (this.analyticPoller && (this.targetDuration = this.analyticPoller.getRetry()), !t) return;
            if (this.getLastAnalyticUpdate() && t.toString() === this.getLastAnalyticUpdate().toString()) return void p.d(c, "Content unchanged.  Analytic update not delivered");
            if (!t.hasAdBreaks()) return void p.d(c, "No ad breaks in payload; discarding");
            p.trace("sdk analytics: " + t.getLinearAdBreaks().length + " " + t.getNonLinearAdBreaks().length + " " + t.getDisplayAdBreaks().length);
            let e = !1;
            for (let i of t.getLinearAdBreaks()) if (0 === i.getAdverts().length) {
                let t = new at(this.getPlayhead());
                this.getReportsManager().fireBeacon(i.getTrackingReport("breakStart", !0), t), this.getReportsManager().fireBeacon(i.getTrackingReport("breakEnd", !0), t)
            } else this.linearAdBreaks.push(i), e = !0;
            for (let i of t.getNonLinearAdBreaks()) this.nonLinearAdBreaks.push(i), e = !0;
            for (let i of t.getDisplayAdBreaks()) this.displayAdBreaks.push(i), e = !0;
            e && this.getReportsManager().raiseAnalyticUpdateCallback(), this.pendingTimedMetadata && (p.d(l, "Process pending metadata: " + this.pendingTimedMetadata), this.onTimedMetadata(this.pendingTimedMetadata), this.pendingTimedMetadata = null), this.processHistoricalData(), this.setLastAnalyticUpdate(t)
        }

        onPlaybackContinue() {
            this.isPlaybackBuffering() && (this.getCurrentAdvert() ? this.scheduleAdvertEnd() : this.getCurrentAdBreak() && this.scheduleAdvertBreakEnd(this.interSegmentTimeout)), super.onPlaybackContinue()
        }

        onPlaybackPause() {
            super.onPlaybackPause(), this.cancelScheduleWatchdog()
        }

        onPlaybackResume() {
            this.isNotPlaying() && !this.isPlaybackBuffering() && (this.getCurrentAdvert() ? this.scheduleAdvertEnd(null) : this.getCurrentAdBreak() && this.scheduleAdvertBreakEnd(this.interSegmentTimeout)), super.onPlaybackResume()
        }

        onPlaybackStall() {
            super.onPlaybackStall(), this.cancelScheduleWatchdog()
        }

        onPlaybackStart(t) {
            this.isNotPlaying() ? this.getSessionResult() !== ht.INITIALISED ? p.w("Reporting START when session has not been initialised") : (super.onPlaybackStart(t), this.analyticPoller.start()) : p.w("Reporting START when start has already been reported")
        }

        onTimedMetadata(t) {
            if (p.d(l, "Received metadata: " + t + ", timestamp: " + t.getTimestamp()), this.isPlaybackBuffering()) return void p.w("Playback buffering - should not be receiving timed metadata");
            if (this.isNotPlaying()) return void p.w("Playback not playing - should not be receiving timed metadata");
            if (this.scheduleAdvertEnd(t), t.isDuplicate(this.lastTimedMetadata)) return void p.d(l, "Duplicate metadata: " + t);
            let e = t.getMediaId(), i = this.getFirstAdvertRemovingAllPrevious(e);
            return i ? this.isMetadataInSequence(this.lastTimedMetadata, t) ? (this.lastTimedMetadata = t, void this.handleMetaDataInSequence(i, t)) : (p.d(l, "Metadata out of sequence"), this.pendingTimedMetadata = null, this.lastTimedMetadata = t, void this.handleMetaDataOutOfSequence(i, t)) : (t.isFirstInSequence() ? (p.d(l, "FIRST pending metadata for advert " + e), this.pendingTimedMetadata = t, this.lastTimedMetadata = null, this.analyticPoller && this.analyticPoller.request()) : t.isLastInSequence() && this.getSessionProperties().getFireHistoricalBeacons() && this.pendingTimedMetadata && (p.d(l, "LAST pending metadata for advert: " + e + " .  Moving to historical list"), this.historicalTimedMetadata.push(this.pendingTimedMetadata), this.pendingTimedMetadata = null), void this.onAdvertBreakStart(null))
        }

        onTimeout() {
            this.setState(ht.TIMEOUT), this.analyticPoller.stop(), this.getReportsManager().raiseSessionTimeoutCallback()
        }

        parseManifestResponse(t, e) {
            let i = t, r = null;
            qt.isHlsManifest(i) ? (p.d(c, "Processing HLS master playlist: " + e), r = qt.parse(e, i)) : (p.d(c, "Processing DASH manifest: " + e), r = Vt.parse(i)), r ? k(r.getAnalyticUrl()) ? (this.setPlaybackUrl(e), p.e("Analytics URL not found in manifest payload"), p.w("Playlist/manifest processing unsuccesful"), this.completeWithStatus(ht.NO_ANALYTICS, 0)) : z(r.getAnalyticUrl()) ? (this.setPlaylistProperties(r), this.interSegmentTimeout = r.getIntersegmentTimeout(), this.completeWithStatus(ht.INITIALISED, 0), p.d(s, "Successful.  URL: " + this.getPlaybackUrl())) : (this.setPlaybackUrl(e), p.e("Malformed analytics URL in manifest payload"), p.w("Playlist/manifest processing unsuccessful"), this.completeWithStatus(ht.NO_ANALYTICS, dt)) : (this.setPlaybackUrl(null), p.w("Playlist/manifest processing unsuccesful"), this.completeWithStatus(ht.NO_ANALYTICS, pt))
        }

        processHistoricalData() {
            let t = this.getCurrentAdBreak();
            if (t) for (let e of this.historicalTimedMetadata) {
                let i = e.getMediaId(), r = t.getAdvertFromYospaceId(i);
                if (r) {
                    p.d(o, "Firing beacon for historical advert: " + i);
                    let t = new at(this.getPlayhead(), r.getStart(), r.getLinearCreative().getAssetUri(), r.getMacroSubstitutions()),
                        e = [];
                    for (let [i, n] of r.getTrackingSchedule()) {
                        e.push(i);
                        let s = r.getTrackingReportLinear(n);
                        s && (p.d(o, "Firing beacon(s) for event: " + i), this.getReportsManager().fireBeacon(s, t))
                    }
                    this.removeKeysFromTrackingSchedule(e)
                }
            }
            this.historicalTimedMetadata = []
        }

        scheduleAdvertBreakEnd(t) {
            this.cancelScheduleWatchdog(), this.advertEndWatchdog = setTimeout(this.metadataWatchdogEndBreak.bind(this), t), p.d(l, "Scheduled adbreak end watchdog timer: " + t + "ms")
        }

        scheduleAdvertEnd(t) {
            this.cancelScheduleWatchdog();
            let e = this.getMetadataTimeout(t);
            this.advertEndWatchdog = setTimeout(this.metadataWatchdog.bind(this), e), p.d(l, "Scheduled advert end watchdog timer: " + e + "ms")
        }

        shutdown() {
            super.shutdown(), this.cancelScheduleWatchdog(), this.analyticPoller && (this.analyticPoller.shutdown(), this.analyticPoller = null, p.d(s, "Analytic poller cancelled"))
        }

        setPlaylistProperties(t) {
            this.setIdentifier(t.getSessionIdentifier()), this.setAnalyticsUrl(t.getAnalyticUrl()), this.setPlaybackUrl(t.getLocation())
        }

        metadataWatchdog() {
            p.w("Watchdog timer expired before metadata was received"), this.pendingTimedMetadata ? this.onAdvertBreakEnd() : this.onAdvertEnd(Xt.NOT_PLAYED_OUT)
        }

        metadataWatchdogEndBreak() {
            p.w("Watchdog timer expired before metadata was received"), this.onAdvertBreakEnd()
        }
    }

    const Qt = /(.+?:\/\/)/;

    class $t extends Ot {
        static create(t, e, i) {
            let r = new $t(e);
            if (!i) return r.initialiseSession(t);
            r.initialiseSession(t).then(() => {
                p.d(s, "Session initialised")
            }).catch(() => {
                p.d(s, "Session failed to initialise")
            }).finally(() => {
                i(new V(r))
            })
        }

        constructor(t) {
            super(t)
        }

        canSkip() {
            return this.policyHandler ? this.policyHandler.canSkip(this.getPlayhead(), this.linearAdBreaks, this.duration) : 0
        }

        getContentPositionForPlayhead(t) {
            if (0 === this.duration || 0 === t) return 0;
            if (0 === this.linearAdBreaks.length) return t;
            for (let e of this.linearAdBreaks) if (e.getStart() <= t && t < e.getStart() + e.getDuration()) {
                t = e.getStart() + e.getDuration();
                break
            }
            let e = 0, i = t;
            for (; e < this.linearAdBreaks.length && this.linearAdBreaks[e].getStart() < t;) i -= this.linearAdBreaks[e++].getDuration();
            return i
        }

        getPlaybackMode() {
            return lt.VOD
        }

        getPlayheadForContentPosition(t) {
            if (0 === this.linearAdBreaks.length) return t;
            let e = 0;
            for (; e < this.linearAdBreaks.length && this.linearAdBreaks[e].getStart() <= t;) t += this.linearAdBreaks[e++].getDuration();
            return t
        }

        initialiseSession(t) {
            return new Promise((e, i) => {
                p.trace("sdk init"), z(t) || (this.completeWithStatus(ht.FAILED, dt), i(this)), Mt.get(t, {method: "GET"}, this.sessionProperties.getRequestTimeout(), this.sessionProperties.getCustomHttpHeaders()).then(r => {
                    r.ok ? r.text().then(i => {
                        _t.parse(i, this).then(i => {
                            !i || 0 === i.getStreamDuration() || k(i.getHostNode() || k(i.getHostSuffix())) ? (this.setPlaybackUrl(t), this.logVmapParseWarning(i), i ? (this.completeWithStatus(ht.NO_ANALYTICS, 0), e(this)) : (this.completeWithStatus(ht.NO_ANALYTICS, pt), e(this))) : (this.initialiseFromAnalyticData(i, this.findScheme(t)), p.d(c, i.toString()), this.completeWithStatus(ht.INITIALISED, 0), e(this))
                        })
                    }) : (p.e("VMAP request failed.  URL: " + t + ", status: " + r.status + ", error: " + r.statusText), this.completeWithStatus(ht.FAILED, r.status), i(this))
                }).catch(e => {
                    p.e("VMAP request failed.  URL: " + t + ", error: " + e), this.completeWithStatus(ht.FAILED, ct), i(this)
                })
            })
        }

        logVmapParseWarning(t) {
            let e = `Unable to parse VMAP data.\n - Stream duration: ${t ? t.getStreamDuration() : "null"}\n - Host node: ${t ? t.getHostNode() : "null"}\n - Host suffix: ${t ? t.getHostSuffix() : null}`;
            p.d(s, e)
        }

        findScheme(t) {
            if (Qt.exec(t)) {
                return Qt.exec(t)[1]
            }
            return p.w("Unable to match scheme in primary URL.  Assuming http://"), "http://"
        }

        onPlayerEvent(t, e) {
            t !== tt.SEEK && t !== tt.ADVERT_SKIP && t !== tt.REWIND || (this.didSeek = !0), super.onPlayerEvent(t, e)
        }

        onPlayheadUpdate(t) {
            this.handleHeartbeat(t), super.onPlayheadUpdate(t)
        }

        setAdBreaksInactivePriorTo(t) {
            super.setAdBreaksInactivePriorTo(t)
        }

        setDuration(t) {
            this.duration = t
        }
    }
}]);